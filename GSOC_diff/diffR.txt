Only in GabrielMccoy/pandemonium/R: coordinates.R
diff GabrielMccoy/pandemonium/R/data.R ushiLaa/pandemonium/R/data.R
1,2c1
<
< #' @title bikes with activations
---
> #' Example data computed for B anomaly observables.
4c3,5
< #' @description data from Ursula
---
> #' A list containing predictions (pred), parameters (wc), inverse covariance
> #' matrix (covInv) and observed values (exp) for the parameters C9 and C10 and
> #' a set of neutral B decay observables.
6,11c7,9
< #' @format a list  of 2 dataframes
< #' \describe{
< #'   \item{space1}{dataframe 731 obs of 10 variables (cluster space)}
< #'   \item{space2}{dataframe 731 obs of 6 variables (space2)}
< #' }
< "Bikes"
---
> #' @format A list with four entries
> #' @references TODO
> "b_anomaly"
Only in GabrielMccoy/pandemonium/R: dimensionReduction.R
diff GabrielMccoy/pandemonium/R/helper.R ushiLaa/pandemonium/R/helper.R
0a1,48
> #' Compute coordinates for all points
> #'
> #' @param coord name of coordinates to be computed
> #' @param useCov should correlation be included in the coordinates
> #' @param pred matrix of predicted values for all points
> #' @param covInv inverse covariance matrix
> #' @param exp experimentally observed values
> #' @param user_coord user coordinates returned with coord=User
> #' @return matrix with coordinate representation of all points
> #' @export
> getCoords <- function(coord, useCov, pred, covInv, exp, user_coord=NULL){
>
>   if(coord=="User") return(as.matrix(user_coord))
>
>   n <- nrow(pred)
>   pred <- as.matrix(pred)
>   nc <- ncol(pred)
>   coord_mat <- matrix(nrow = n, ncol = nc)
>
>   if (coord=="normalised"){
>     for (i in 1:n){
>       for (j in 1:nc){
>         if(useCov) coord_mat[i, j] <- sum(covInv[j,] * pred[i,]) / sqrt(covInv[j, j])
>         else coord_mat[i, j] <- as.numeric(pred[i, j]) / sqrt(solve(covInv)[j, j])
>       }
>     }
>     return(coord_mat)
>   }
>   if (coord=="Pull"){
>     for (i in 1:n){
>       for (j in 1:nc){
>         if(useCov) coord_mat[i, j] <- sum(covInv[j,] * (pred[i,] - exp$value)) / sqrt(covInv[j, j])
>         else coord_mat[i, j] <- as.numeric((pred[i, j] - exp$value[j]) / sqrt(solve(covInv)[j, j]))
>       }
>     }
>     return(coord_mat)
>   }
>   if (coord=="p-val"){
>     for (i in 1:n){
>       for (j in 1:nc){
>         if(useCov) coord_mat[i, j] <- stats::pchisq((sum(covInv[j,] * (pred[i,] - exp$value)) / sqrt(covInv[j, j]))^2, df=1)
>         else coord_mat[i, j] <- stats::pchisq((as.numeric((pred[i, j] - exp$value[j]) / sqrt(solve(covInv)[j, j])))^2, df=1)
>       }
>     }
>     return(coord_mat)
>   }
> }
>
12a61,75
> #' Compute chi2 value for all points
> #'
> #' @param pred matrix of predicted values for all points
> #' @param covInv inverse covariance matrix
> #' @param exp experimentally observed values
> #' @return vector with chi2 values
> #' @export
> computeChi2 <- function(pred, covInv, exp){
>   chi2 <- double(nrow(pred))
>   for (i in 1:nrow(pred)){
>     chi2[i] <- as.matrix(exp$value - pred[i,]) %*% covInv %*% t(as.matrix(exp$value - pred[i,]))
>   }
>   return(chi2)
> }
>
52d114
< #' @importFrom rlang .data
65,66c127,128
<       id1 <- dplyr::filter(benchmarks, .data$group == i)$id
<       id2 <- dplyr::filter(benchmarks, .data$group == j)$id
---
>       id1 <- dplyr::filter(benchmarks, group == i)$id
>       id2 <- dplyr::filter(benchmarks, group == j)$id
117,120c179,182
<                      x$ch, x$pearsongamma, x$dunn,
<                      x$corrected.rand,
<                      max(bmInfo$r), max(bmInfo$d),
<                      bmMinDist))
---
>                    x$ch, x$pearsongamma, x$dunn,
>                    x$corrected.rand,
>                    max(bmInfo$r), max(bmInfo$d),
>                    bmMinDist))
124a187,222
> #' Bin points based on chi2
> #'
> #' Map to values of sigma and compute equidistant binning in sigma.
> #'
> #' @param chivals vector with chi2 values
> #' @param ndf number of parameters (degrees of freedom of the chi2 distribution)
> #' @param k number of bins
> #' @return bin assignment for each point
> #' @export
> chi2bins <- function(chivals, ndf, k){
>   chimin <- min(chivals)
>   # map chivals to sigmas
>   sigvals <- sqrt(stats::qchisq(stats::pchisq(chivals-chimin, ndf), 1))
>   sigvals <- pmin(sigvals, 5)
>   # get bins in sigma
>   sigmabins <- seq(0, max(sigvals), length.out = k+1)
>   sigbinned <- cut(sigvals, sigmabins,
>                    include.lowest = TRUE,
>                    labels = FALSE)
>   sigbinned
> }
>
> #' Compute sigma
> #'
> #' Map chi2 to sigma, with cutoff (overflow) at 5 sigma
> #'
> #' @param chivals vector with chi2 values
> #' @param ndf number of parameters (degrees of freedom of the chi2 distribution)
> #' @return vector with sigma values
> #' @export
> computeSigma <- function(chivals, ndf){
>   chimin <- min(chivals)
>   # map chivals to sigmas, cutoff at 5
>   pmin(sqrt(stats::qchisq(stats::pchisq(chivals-chimin, ndf), 1)), 5)
> }
>
141c239
< #' function for assigning colouring, palette and labels
---
> #' Wrapper to prepare data for tour
143,149c241,246
< #' @param choice choice of colouring for an output
< #' @param rv reactive variables
< #'
< #' @returns list containing colour assignment, palette and labels for use in plotting
< #' @keywords internal
< #'
< colourHelper <- function(choice,rv){
---
> #' @param coord coordinate representation of all points
> #' @param col color vector
> #' @param pch pch vector
> #' @param addOrigin set TRUE to add point through the origin
> #' @return list with formatted tour input
> tour_coord <- function(coord, col, pch, addOrigin=FALSE){
151,165c248,255
<   ret$colour<- switch(choice,
<                       "clustering"  = rv$groups,
<                       "user"        = rv$user.group,
<                       "bins"        = rv$colSig,
<                       "score"       = rank(rv$value$score))
<   ret$pal <-    switch(choice,
<                        "clustering"  = rv$pal,
<                        "user"        = rv$user.pal,
<                        "bins"        = rv$palSig,
<                        "score"       = rv$scorecol)
<   ret$label <- switch(choice,
<                       "clustering"  = paste(rv$groups,rv$label,rv$value$interest),
<                       "user"        = paste(rv$user.group,rv$label,rv$value$interest),
<                       "bins"        = paste(rv$value$bins,rv$label,rv$value$interest),
<                       "score"       = paste(rv$label,rv$value$interest))
---
>   ret$coord <- as.matrix(as.data.frame(coord))
>   ret$col <- col
>   ret$pch <- pch
>   if(addOrigin){
>     ret$coord <- rbind(ret$coord, 0) # adding origin
>     ret$col <- c(col, "black")
>     ret$pch <- c(pch, 18)
>   }
diff GabrielMccoy/pandemonium/R/output.R ushiLaa/pandemonium/R/output.R
1c1
< #' Write space2, coordinates and cluter assingment to a CSV file
---
> #' Write WC, coordinates and cluter assingment to a CSV file
3c3
< #' Settings include: metric, linkage, k, plotType
---
> #' Settings include: coord, useCov, metric, linkage, k, plotType
5,6c5
< #' @param space1 cluster space matrix
< #' @param cov covariance matrix
---
> #' @param pred prediction matrix
8c7
< #' @param space2 space2 matrix
---
> #' @param wc matrix specifying the model parameters (on a grid)
14d12
< #' @param getCoords function to calculate coordinates
16,19c14,17
< writeResults <- function(space1, cov, covInv, space2, exp, settings, filename,
<                          user_coord=NULL, user_dist=NULL, getCoords = normCoords){
<   n <- nrow(space1)
<   chi2 <- computeChi2(space1, covInv, exp)
---
> writeResults <- function(pred, covInv, wc, exp, settings, filename,
>                       user_coord=NULL, user_dist=NULL){
>   n <- nrow(pred)
>   chi2 <- computeChi2(pred, covInv, exp)
22,26c20,24
<   sm <- which.min(rowSums(abs(space2)))
<   x <- colnames(space2)[1]
<   y <- colnames(space2)[2]
<   cond <- 1:nrow(space2)
<   coord <- getCoords(space1, cov, covInv, exp, user_coord)
---
>   sm <- which.min(rowSums(abs(wc)))
>   x <- colnames(wc)[1]
>   y <- colnames(wc)[2]
>   cond <- 1:nrow(wc)
>   coord <- getCoords(settings$coord, settings$useCov, pred, covInv, exp, user_coord)
33c31
<   isBenchmark <- rep(0, nrow(space2))
---
>   isBenchmark <- rep(0, nrow(wc))
37c35
<   space2 %>%
---
>   wc %>%
41c39
<     utils::write.csv(filename, row.names = FALSE, quote = FALSE)
---
>     write.csv(filename, row.names = FALSE, quote = FALSE)
diff GabrielMccoy/pandemonium/R/plotting.R ushiLaa/pandemonium/R/plotting.R
1c1
< #' Show clusters in parameter space
---
> #' Make parallel coordinate plot
3,14c3,7
< #' Parameter values no longer need to be on a regular grid pattern for this plot.(modified)
< #'
< #' @param wc parameter values as matrix
< #' @param x,y variables names (as string) to map to x and y axis
< #' @param interest index values for the intersting points
< #' @param bmID index values of benchmarks
< #' @param col color vector according to cluster assignment
< #' @param cond row numbers of points used for conditioning
< #' @param groups grouping assignments used to make alphahull
< #' @param pal pallete used for group colouring of alphahull
< #' @param a alpha value for alpha hull
< #' @param showalpha boolean value to calculate and show alpha hulls
---
> #' @param dat coordinate representation of points
> #' @param gr grouping from clustering
> #' @param benchmarkIds index values of benchmarks
> #' @param s rescale (default=FALSE)
> #' @param a alpha transarancy for drawing non-benchmark points (default=0.2)
16d8
< #' @importFrom rlang .data
18,19c10
< plotWC <- function (wc, x, y, interest, bmID, col, cond = NULL, groups = NULL, pal = NULL, a = 0.2, showalpha = F) {
<   if (is.null(cond)){cond <- 1:nrow(wc)}
---
> plotPC <- function(dat, gr, benchmarkIds, s=FALSE, a=0.2, ctr=TRUE){
21c12
<   p <- ggplot2::ggplot(wc[cond, ], ggplot2::aes(.data[[x]], .data[[y]]))
---
>   colnames(dat) <- paste0("O",1:ncol(dat))
23,51c14,15
<   if (!is.null(groups) & showalpha) {
<     for (group in unique(groups)) {
<       group_indices <- intersect(cond, which(groups == group))
<       data <- unique(wc[group_indices, c(x, y)])
<       if (nrow(data) > 3) {
<         hull <- tryCatch(alphahull::ahull(data, alpha = a), error = function(e) {
<           warning(paste("alphahull failed for group",group,"no hull will be plotted"),call. = F)
<           return(NULL)
<         })
<         if(is.null(hull)){next}
<         edges <- hull$ashape$edges
<         segment_df <- data.frame(
<           x = edges[,3],
<           y = edges[,4],
<           xend = edges[,5],
<           yend = edges[,6],
<           group = as.factor(group)
<         )
<         p <- p + ggplot2::geom_segment(data = segment_df,
<               ggplot2::aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend),colour = pal[group])
<       }
<     }
<   }
<   p + ggplot2::geom_point(color = col[cond]) +
<     ggplot2::geom_point(data = wc[interest,], shape = 1, size = 3) +
<     ggplot2::geom_point(data = wc[bmID,], shape = 5, size = 3) +
<     ggplot2::theme_bw() + ggplot2::ggtitle("Cluster assignment in parameter space") +
<     ggplot2::theme(aspect.ratio = 1, legend.position = "none")
< }
---
>   alphalvl <- rep(a, nrow(dat))
>   alphalvl[benchmarkIds] <- 1
53,74c17,29
< #' Make coordinate plot
< #'
< #' Parameter values no longer need to be on a regular grid pattern for this plot.(modified)
< #'
< #' @param coord coordinate representation of points
< #' @param x,y variables names (as string) to map to x and y axis
< #' @param wc parameter values as matrix
< #' @param obs observable to plot
< #' @param cond row numbers of points used for conditioning
< #' @return ggplot
< #'
< #' @importFrom rlang .data
< #' @export
< plotObs <- function (coord, x, y, wc, obs, cond = NULL) {
<   if (is.null(cond)){cond <- 1:nrow(wc)}
<   dat <- coord[cond, ]
<   dat %>% tourr::rescale() %>% tibble::as_tibble() %>% cbind(wc[cond, ]) %>%
<     ggplot2::ggplot(ggplot2::aes(.data[[x]], .data[[y]], color = .data[[obs]])) +
<     ggplot2::geom_point() + ggplot2::guides(color = "none") +
<     ggplot2::scale_color_viridis_c() + ggplot2::theme_bw() +
<     ggplot2::ggtitle(paste0("Centered coordinate values for ",
<                             obs)) + ggplot2::theme(aspect.ratio = 1)
---
>   dat %>%
>     scale(center = ctr, scale = s) %>%
>     tibble::as_tibble() %>%
>     tibble::add_column(gr = factor(gr)) %>%
>     tibble::add_column(alphalvl = alphalvl) %>%
>     GGally::ggparcoord(columns=1:ncol(dat), groupColumn = "gr",
>                        scale = "globalminmax", alphaLines = "alphalvl") +
>     ggplot2::scale_color_brewer(palette="Dark2") +
>     ggplot2::theme_bw() +
>     ggplot2::theme(axis.title.y=ggplot2::element_blank(),
>           axis.text.y=ggplot2::element_blank(),
>           axis.ticks.y=ggplot2::element_blank(),
>           legend.position = "none")
77c32
< #' Plot sigma bins in parameter space
---
> #' Show clusters in parameter space
79c34,35
< #' Parameter values no longer need to be on a regular grid pattern for this plot.(modified)
---
> #' Parameter values need to be on a regular grid for correct appearance of
> #' this plot.
82,84d37
< #' @param interest logical vector showing that points are intersting
< #' @param bmID index values for the benchmark points
< #' @param sigmabins binning in sigma
86c39,41
< #' @param binName name for title
---
> #' @param sm,bf index values for the SM and BF point
> #' @param benchmarkIds index values of benchmarks
> #' @param col color vector according to cluster assignment
88,89d42
< #' @param colourSet RColorBrewer set for colouring
< #' @importFrom rlang .data
92,100c45,59
< plotSigBin <- function (wc, interest, bmID, sigmabins, x, y, binName, cond = NULL, colourSet = "Set2") {
<   if (is.null(cond)){cond <- 1:nrow(wc)}
<   palSig <- RColorBrewer::brewer.pal(length(unique(sigmabins)), colourSet)
<   colSig <- palSig[sigmabins]
<   ggplot2::ggplot(wc[cond, ], ggplot2::aes(.data[[x]], .data[[y]])) +
<     ggplot2::geom_point(color = colSig[cond]) +
<     ggplot2::geom_point(data = wc[interest,], shape = 1, size = 3) +
<     ggplot2::geom_point(data = wc[bmID,], shape = 5, size = 3) +
<     ggplot2::theme_bw() + ggplot2::ggtitle(paste(binName,"bins in parameter space")) +
---
> plotWC <- function(wc, x, y, sm, bf, benchmarkIds, col, cond=NULL){
>   if(is.null(cond)) cond <- 1:nrow(wc)
>   x_id <- which(colnames(wc)==x)
>   y_id <- which(colnames(wc)==y)
>   ggplot2::ggplot(wc[cond,], ggplot2::aes_string(x, y)) +
>     ggplot2::geom_tile(fill= col[cond]) +
>     ggplot2::geom_point(ggplot2::aes(x = as.numeric(wc[sm,x_id]),
>                                      y = as.numeric(wc[sm,y_id])),
>                         shape=1, size=3) +
>     ggplot2::geom_point(ggplot2::aes(x = as.numeric(wc[bf,x_id]),
>                                      y = as.numeric(wc[bf,y_id])),
>                         shape=8, size=3) +
>     ggplot2::geom_point(data = wc[benchmarkIds,], shape=5, size=3) +
>     ggplot2::theme_bw() +
>     ggplot2::ggtitle("Cluster assignment in parameter space") +
104,158d62
< #' Plot chi2
< #'
< #' Parameter values no longer need to be on a regular grid pattern for this plot.(modified)
< #'
< #' @param wc parameter values as matrix
< #' @param chi2 vector with chi2 values
< #' @param x,y variables names (as string) to map to x and y axis
< #' @param scoreName name for title
< #' @param cond row numbers of points used for conditioning
< #' @return ggplot
< #' @importFrom rlang .data
< #' @export
< plotChi2 <- function (wc, chi2, x, y, scoreName = NULL, cond = NULL) {
<   if (is.null(cond)){cond <- 1:nrow(wc)}
<   dplyr::mutate(wc[cond, ], chi2 = chi2[cond]) %>% ggplot2::ggplot(ggplot2::aes(.data[[x]], .data[[y]], color = .data[["chi2"]])) +
<     ggplot2::geom_point() + ggplot2::guides(color = "none") +
<     ggplot2::scale_color_viridis_c() + ggplot2::theme_bw() +
<     ggplot2::ggtitle(paste(scoreName, "values")) + ggplot2::theme(aspect.ratio = 1)
< }
<
< #' Make parallel coordinate plot
< #'
< #' @param coord coordinate representation of points
< #' @param groups grouping from clustering is numeric or can be made numeric by as.numeric
< #' @param benchmarkIds index values of benchmarks
< #' @param filt  filter of groups
< #' @param c centre
< #' @param s rescale (default=TRUE)
< #' @param a alpha transarancy for drawing non-benchmark points (default=0.2)
< #' @param pal pallete for colour assignment
< #' @return ggplot
< #' @export
< plotPC <- function(coord, groups, benchmarkIds, filt, c=T, s=T, a=0.2, pal = NULL){
<   alphalvl <- rep(a, nrow(coord))
<   alphalvl[benchmarkIds] <- 1
<   if (is.null(pal)) {pal <- RColorBrewer::brewer.pal(8,"Dark2")}
<   scale(coord, center = c, scale = s) %>%
<     tibble::as_tibble() %>%
<     tibble::add_column(gr = as.factor(groups)) %>%
<     tibble::add_column(alphalvl = alphalvl) %>%
<     dplyr::filter(.data$gr %in% filt) %>%
<     ggpcp::pcp_select(-c(.data$gr,.data$alphalvl)) %>%
<     ggpcp::pcp_arrange()%>%
<     ggplot2::ggplot(ggpcp::aes_pcp())+
<     ggpcp::geom_pcp_axes() +
<     ggpcp::geom_pcp(ggplot2::aes(colour = .data$gr, alpha = .data$alphalvl)) +
<     ggplot2::scale_color_manual(values = pal[sort(as.numeric(filt))]) +
<     ggplot2::ggtitle("Parallel coordinate plot")+
<     ggplot2::theme_bw() +
<     ggplot2::theme(axis.title.y=ggplot2::element_blank(),
<                    axis.title.x=ggplot2::element_blank(),
<                    axis.text.x =ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
<                    legend.position = "none")
< }
<
175,176d78
<
<
188c90
<   ggplot2::ggplot(cstats, ggplot2::aes({{"k"}}, {{stat}})) +
---
>   ggplot2::ggplot(cstats, ggplot2::aes_string("k", stat)) +
195c97
< #' Plot dimension reduction plot
---
> #' Make coordinate plot
197,208c99,100
< #' @param coord1 coordinates in space 1
< #' @param coord2 coordinates in space 2
< #' @param d_mat1 distance matrix in space 1
< #' @param d_mat2 distance matrix in space 2
< #' @param data either "space1" or "space2"
< #' @param colouring either "clustering", "user", "bins" or "score"
< #' @param dimReduction function to calculate dimension reduction with $Y being the new n x 2 matrix
< #' @param algorithm name for algorithm used for labeling plot
< #' @param group grouping of points from clustering
< #' @param score score values and bins
< #' @param user_group user defined grouping
< #' @param pch factor with 2 levels 1 will be plotted as a circle 2 will be plotted as an o
---
> #' Parameter values need to be on a regular grid for correct appearance of
> #' this plot.
210c102,107
< #' @returns plotly plot
---
> #' @param coord coordinate representation of points
> #' @param x,y variables names (as string) to map to x and y axis
> #' @param wc parameter values as matrix
> #' @param obs observable to plot
> #' @param cond row numbers of points used for conditioning
> #' @return ggplot
211a109,125
> plotObs <- function(coord, x, y, wc, obs, cond){
>   dat <- coord[cond,]
>   colnames(dat) <- paste0("O",1:ncol(coord))
>   dat %>%
>     tourr::rescale() %>%
>     tibble::as_tibble() %>%
>     cbind(wc[cond,]) %>%
>     ggplot2::ggplot(ggplot2::aes_string(x, y, fill=obs)) +
>     ggplot2::geom_tile() +
>     ggplot2::guides(fill = FALSE) +
>     ggplot2::scale_fill_viridis_c() +
>     ggplot2::theme_bw() +
>     ggplot2::ggtitle(paste0("Centered coordinate values for ", obs)) +
>     ggplot2::theme(aspect.ratio = 1)
> }
>
> #' Plot chi2
213,226c127,145
< plotDimRed <- function(coord1, coord2, d_mat1, d_mat2, data, colouring, dimReduction, algorithm, group, score, user_group, pch){
<   set.seed(2025)
<   colour<- switch(colouring,
<                   "clustering"  = group,
<                   "user"        = user_group,
<                   "bins"        = score$bins,
<                   "score"       = rank(score$score))
<   pal <-    switch(colouring,
<                    "clustering"  = RColorBrewer::brewer.pal(length(unique(colour)),"Dark2"),
<                    "user"        = RColorBrewer::brewer.pal(length(unique(colour)), "Set3"),
<                    "bins"        = RColorBrewer::brewer.pal(length(unique(colour)),"Set2"),
<                    "score"       = viridis::viridis(length(colour)))
<   dim.title   <- paste(algorithm, "embedding")
<   dim.axislab <- algorithm
---
> #' Parameter values need to be on a regular grid for correct appearance of
> #' this plot.
> #'
> #' @param wc parameter values as matrix
> #' @param chi2 vector with chi2 values
> #' @param x,y variables names (as string) to map to x and y axis
> #' @param cond row numbers of points used for conditioning
> #' @return ggplot
> #' @export
> plotChi2 <- function(wc, chi2, x, y, cond){
>   dplyr::mutate(wc[cond,], chi2 = chi2[cond]) %>%
>     ggplot2::ggplot(ggplot2::aes_string(x, y, fill="chi2")) +
>     ggplot2::geom_tile() +
>     ggplot2::guides(fill = FALSE) +
>     ggplot2::scale_fill_viridis_c() +
>     ggplot2::theme_bw() +
>     ggplot2::ggtitle("Chi2 values") +
>     ggplot2::theme(aspect.ratio = 1)
> }
228,233c147,171
<   if(data=="space1"){
<     mat <- dimReduction(mat = coord1, dist = d_mat1)$Y
<   } else {
<     mat <-  dimReduction(mat = coord2, dist = d_mat2)$Y
<   }
<   colnames(mat) <- c("dim1","dim2")
---
> #' Plot sigma bins in parameter space
> #'
> #' Parameter values need to be on a regular grid for correct appearance of
> #' this plot.
> #'
> #' @param wc parameter values as matrix
> #' @param sm,bf index values for the SM and BF point
> #' @param bmID index values for the benchmark points
> #' @param sigmabins binning in sigma
> #' @param x,y variables names (as string) to map to x and y axis
> #' @param cond row numbers of points used for conditioning
> #' @return ggplot
> #' @export
> plotSigBin <- function(wc, sm, bf, bmID, sigmabins, x, y, cond){
>   palSig <- RColorBrewer::brewer.pal(max(sigmabins), "Set2")
>   colSig <- palSig[sigmabins]
>   ggplot2::ggplot(wc[cond,], ggplot2::aes_string(x, y)) +
>     ggplot2::geom_tile(fill= colSig[cond]) +
>     ggplot2::geom_point(data=wc[sm,],  shape=1, size=3) +
>     ggplot2::geom_point(data=wc[bf,], shape=8, size=3) +
>     ggplot2::geom_point(data = wc[bmID,], shape=5, size=3) +
>     ggplot2::theme_bw() +
>     ggplot2::ggtitle("Sigma bins in parameter space") +
>     ggplot2::theme(aspect.ratio = 1, legend.position = "none")
> }
235,244c173,192
<   plotly::plot_ly(as.data.frame(mat), x = ~dim1, y = ~dim2,
<                   color = as.factor(colour),
<                   symbol = pch, symbols = c("circle","o"),
<                   colors = pal, marker = list(showscale = FALSE)) %>%
<     plotly::add_trace(type = "scatter", mode = "markers") %>%
<     plotly::layout(title = dim.title,
<                    xaxis = list(title = paste(dim.axislab,1),
<                                 scaleanchor = "y"),
<                    yaxis = list(title = paste(dim.axislab,2)),
<                    showlegend = FALSE)
---
> #' Make GIF of tour animation.
> #'
> #' Renders the tour animation, stored in file tour_animation.gif
> #'
> #' @param coord coordinate representation of the points
> #' @param col color vector according to group assignment
> #' @param pch vector of plotting symbols
> #' @export
> tourGif <- function(coord, col, pch, addOrigin=FALSE){
>   set.seed(2021)
>   colnames(coord) <- paste0("O",1:ncol(coord))
>   if(addOrigin){
>     coord <- rbind(coord, 0) # adding origin
>     col <- c(col, "black")
>     pch <- c(pch, 18)
>   }
>   tourr::render_gif(coord, tourr::grand_tour(),
>                 tourr::display_xy(col = col, pch = pch),
>                 gif_file = "tour_animation.gif",
>                 frames = 100, rescale = FALSE)
247d194
<
251c198
< #' Settings include: metric, linkage, k, plotType
---
> #' Settings include: coord, useCov, metric, linkage, k, plotType
253,260c200,203
< #' @param space1 dataframe of variables in cluster space
< #' @param cov covariance matrix for space 1
< #' @param covInv inverse covariance matrix for space 1
< #' @param exp reference point in space 1
< #' @param space2 dataframe of variables in linked space
< #' @param space2.cov covariance matrix for space 2
< #' @param space2.covInv inverse covariance matrix for space 2
< #' @param space2.exp reference point in space 2
---
> #' @param pred prediction matrix
> #' @param covInv inverse covariance matrix
> #' @param wc matrix specifying the model parameters (on a grid)
> #' @param exp observable reference value (e.g. experimental measurement)
262,267c205,208
< #' @param user_dist user defined distances
< #' @param getCoordsSpace1 function to calculate coordinates in space 1
< #' @param getCoordsSpace2 function to calculate coordinates in space 2
< #' @param getScore function to calculate scores and bins
< #'
< #' @returns ggplot, plotly or detourr plot depending on settings$plotType
---
> #' @param user_coord input coordinate matrix (optional)
> #' @param user_dist input distance matrix (optional)
> #' @param c specification for conditioning
> #' @return ggplot
269,279c210,231
< #'
< makePlots <- function(space1, settings, cov = NULL, covInv = NULL, exp = NULL, space2 = NULL,
<                       space2.cov = NULL, space2.covInv, space2.exp = NULL, user_dist=NULL,
<                       getCoordsSpace1 = normCoords, getCoordsSpace2 = normCoords, getScore = NULL){
<   n <- nrow(space1)
<   cond <- 1:n
<   x <- settings$x
<   y <- settings$y
<
<   coord <- getCoordsSpace2(space1, cov, covInv, exp)
<   try(coord2 <- getCoordsSpace2(space2, space2.cov, space2.covInv, space2.exp))
---
> makePlots <- function(pred, covInv, wc, exp, settings,
>                       user_coord=NULL, user_dist=NULL, c=NULL){
>   n <- nrow(pred)
>   chi2 <- computeChi2(pred, covInv, exp)
>   sig <- computeSigma(chi2, 2)
>   bf <- which.min(chi2)
>   sm <- which.min(rowSums(abs(wc)))
>   if(!is.null(c)){
>     x <- c$x
>     y <- c$y
>     cond <- which(wc[[c$pz1]]==as.numeric(c$vz1))
>     if(! is.null(c$pz2)){
>       cond2 <- which(wc[[c$pz2]]==as.numeric(c$vz2))
>       cond <- intersect(cond, cond2)
>     }
>   }
>   else{
>     x <- colnames(wc)[1]
>     y <- colnames(wc)[2]
>     cond <- 1:nrow(wc)
>   }
>   coord <- getCoords(settings$coord, settings$useCov, pred, covInv, exp, user_coord)
281d232
<   try(dists2 <- getDists(coord2, settings$metric, NULL))
286,297d236
<   #score fuction
<   if (!is.null(getScore)){
<     value<- try(getScore(space1, cov, covInv, exp, space2, space2.cov, space2.exp, settings$k))
<     if (!is.null(value$score)){
<       scorecol <- viridis::viridis(n)[rank(value$score)]
<     }
<     if(!is.null(value$bins)){
<       palSig <- RColorBrewer::brewer.pal(length(unique(value$bins)), "Set2")
<       colSig <- palSig[value$bins]
<     }
<   }
<   #colours
300d238
<   benchmarks <- getBenchmarkInformation(as.matrix(dists), groups)
302,310c240,250
<   pch[value$is.interest] <- 2
<   #make plots
<   if(settings$plotType == "PC"){ return( plotPC(coord, groups, benchmarks$id, settings$filt, c=T, s=T))}
<   else if(settings$plotType == "PCunscaled"){ return(plotPC(coord, groups, benchmarks$id, settings$filt, c=T, s=F))}
<   else if(settings$plotType == "PCnotcentered"){ return(plotPC(coord, groups, benchmarks$id, settings$filt, c=F, s=F))}
<   else if(settings$plotType == "WC") {return(plotWC(space2, x, y, value$is.interest, benchmarks$id, col, groups = groups, pal = pal, a = settings$WCa, showalpha = settings$showalpha))}
<   else if(settings$plotType == "chi2") {return(plotChi2(space2, value$score, x, y, value$scoreName, cond))}
<   else if(settings$plotType == "sigBins"){return(plotSigBin(space2, value$is.interest, benchmarks$id, value$bins,
<                                                             x, y, value$binName, cond, "Set2"))}
---
>   pch[sm] <- 8
>   pch[bf] <- 15
>   sigmabins <- chi2bins(chi2, 2, settings$k)
>   benchmarks <- getBenchmarkInformation(as.matrix(dists), groups)
>   if(settings$plotType == "PC"){ return( plotPC(coord, groups, benchmarks$id))}
>   else if(settings$plotType == "PCscaled"){ return(plotPC(coord, groups, benchmarks$id, TRUE))}
>   else if(settings$plotType == "PCnotcentered"){ return(plotPC(coord, groups, benchmarks$id, ctr=FALSE))}
>   else if(settings$plotType == "WC") {return(plotWC(wc, x, y, sm, bf, benchmarks$id, col, cond))}
>   else if(settings$plotType == "chi2") {return(plotChi2(wc, chi2, x, y, cond))}
>   else if(settings$plotType == "sigBins"){return(plotSigBin(wc, sm, bf, benchmarks$id,
>                                                             sigmabins, x, y, cond))}
312c252
<   else if(settings$plotType %in% names(cstat_names)){return(plotCstat(dists, fit, computeChi2(space1, covInv, exp),
---
>   else if(settings$plotType %in% names(cstat_names)){return(plotCstat(dists, fit, chi2,
314,320c254,255
<   else if(settings$plotType == "Obs"){return(plotObs(coord, x, y, space2, settings$obs, cond))}
<   else if(settings$plotType == "dimRed"){return(plotDimRed(coord, coord2, as.matrix(dists), as.matrix(dists2),
<                                                            settings$dimspace, settings$colouring, settings$dimReduction,
<                                                            settings$algorithm, groups, value, settings$user_group, pch))}
<   else if(settings$plotType== "tour"){return(tourMaker(coord, coord2, groups, value, settings$user_group,
<                                                        settings$tourspace, settings$colouring, settings$out_dim, settings$tour_path, settings$display,
<                                                        settings$radial_start, settings$radial_var, settings$slice_width))}
---
>   else if(startsWith(settings$plotType, "O")){return(plotObs(coord, x, y, wc, settings$plotType, cond))}
>   else if(settings$plotType== "tour"){return(tourGif(coord, col, pch))}
Only in GabrielMccoy/pandemonium/R: scores.R
diff GabrielMccoy/pandemonium/R/server.R ushiLaa/pandemonium/R/server.R
1d0
<
6c5
< #' in the function call.(modified)
---
> #' in the function call.
8,10c7,9
< #' @param df data frame of data assumes space 1 but variables can be changed once loaded
< #' @param cov  covariance matrix (optional)
< #' @param is.inv is the covariance matrix an inverse default FALSE
---
> #' @param pred prediction matrix
> #' @param covInv inverse covariance matrix
> #' @param wc matrix specifying the model parameters (on a grid)
12,16c11
< #' @param space2 dataframe assumed to be in space 2 but can be changed when loaded
< #' @param space2.cov  covariance matrix (optional)
< #' @param space2.exp observable reference value (e.g. experimental measurement)
< #' @param group grouping assignments
< #' @param label point labels
---
> #' @param user_coord input coordinate matrix (optional)
18,22d12
< #' @param dimReduction named list functions used for dimension reduction.
< #' @param getCoords named list containing functions to calculate coordinates
< #' @param getScore named list contaiining functions to calculate scores to be plotted as bins and continuous value.
< #'
< #' @importFrom rlang .data
24,57c14,17
< #'
< pandemonium = function (df, cov = NULL, is.inv = FALSE, exp = NULL, space2 = NULL, space2.cov = NULL, space2.exp = NULL, group = NULL, label = NULL, user_dist = NULL, dimReduction = list(tSNE = tSNE, umap = umap), getCoords = list(normal = normCoords), getScore = NULL)
< {
<   stopifnot(
<     is.null(space2)||nrow(df)==nrow(space2),
<     is.null(cov)||(ncol(df)==nrow(cov)&&ncol(df)==ncol(cov)),
<     is.null(exp)||ncol(df)==length(exp)||(ncol(df)==nrow(exp)&&ncol(exp)==1),
<     is.null(label)||nrow(df)==length(label)||(nrow(df)==nrow(label)&&ncol(label)==1),
<     is.null(group)||nrow(df)==length(group)||nrow(df)==nrow(group),
<     is.null(space2.cov)||(ncol(space2)==nrow(space2.cov)&&ncol(space2)==ncol(space2.cov)),
<     is.null(space2.exp)||ncol(space2)==length(space2.exp)||(ncol(space2)==nrow(space2.exp)&&ncol(space2.exp)==1)
<     )
<   if (any(colnames(df)%in%colnames(space2))||any(colnames(space2)%in%colnames(df))){
<     stop("column names need to be unique across both spaces")
<   }
<   numeric.colnames <- c()
<   nonnumeric.colnames <- c()
<   options(warn = 1)
<   for (var in colnames(df)){
<     if (is.numeric(df[[var]])){
<       numeric.colnames <- append(numeric.colnames,var)
<     } else {
<       warning(paste(var,"in df is non numeric and has been removed"))
<       nonnumeric.colnames <- append(nonnumeric.colnames,var)
<     }
<   }
<   for (var in colnames(space2)){
<     if (is.numeric(space2[[var]])){
<       numeric.colnames <- append(numeric.colnames,var)
<     } else {
<       warning(paste(var,"in space2 is non numeric and has been removed"))
<       nonnumeric.colnames <- append(nonnumeric.colnames,var)
<     }
<   }
---
> #' @examples \dontrun{
> #' pandemonium(b_anomaly$pred, b_anomaly$covInv, b_anomaly$wc, b_anomaly$exp)
> #' }
> pandemonium <- function(pred, covInv, wc, exp, user_coord = NULL, user_dist = NULL){
59,79d18
<   df.colnames <- colnames(df)
<   space2.colnames <- colnames(space2)
<   full.colnames <- c(df.colnames,space2.colnames)
<   group.colnames <- colnames(group)
<
<   if (any(is.na(df),is.na(space2))){
<     filt <- rowSums(is.na(cbind(df,space2)))
<     if (requireNamespace("VIM", quietly = TRUE)) {
<       warning(paste(sum(filt),"NA entries observed, kNN imputation has been used to replace these"))
<       if (any(is.na(df))) {df <- VIM::kNN(df[df.colnames %in% numeric.colnames])}
<       if (any(is.na(space2))) {space2 <- VIM::kNN(space2[space2.colnames %in% numeric.colnames])}
<     }else{
<       warning(paste(sum(filt),"NA entries observed, rows have been removed for containing na values, install VIM for automatic imputation"))
<       df <- df[filt==0,]
<       if (!is.null(space2)) {space2 <- space2[filt==0,]}
<       if (!is.null(group))  {group  <- group[filt==0,]}
<       if (!is.null(label))  {label  <- label[filt==0,]}
<     }
<   }
<
<
81,92c20,30
<   rv$load.app <- FALSE
<   rv$detouring <- FALSE
<   rv$radialWarn <-0
<   rv$colour.choice <- c("clustering")
<   n <- nrow(df)
<   if(is.inv & !is.null(cov)) {
<     covInv <- cov
<     cov <- solve(covInv)}
<
<   lab.choice <-if (is.null(label)){c(choose="",full.colnames)} else {c(choose="",full.colnames,"label")}
<   group.choice <- c(group.colnames,full.colnames)
<
---
>   n <- nrow(pred)
>   ndf <- ncol(wc)
>   chi2 <- computeChi2(pred, covInv, exp)
>   sig <- computeSigma(chi2, ndf)
>   bf <- which.min(chi2)
>   sm <- which.min(rowSums(abs(wc)))
>   rv$x <- colnames(wc)[1]
>   rv$y <- colnames(wc)[2]
>   rv$vz1 <- NULL
>   rv$vz2 <- NULL
>   rv$cond <- 1:nrow(wc)
97,106c35,41
<     if (!is.null(user_dist)) {
<       shiny::updateSelectInput(session, "metric", choices = c("euclidean",
<                                                               "maximum", "manhattan", "canberra", "binary",
<                                                               "minkowski", "user"))
<       shiny::updateSelectInput(session, "metricA", choices = c("euclidean",
<                                                                "maximum", "manhattan", "canberra", "binary",
<                                                                "minkowski", "user"))
<       shiny::updateSelectInput(session, "metricB", choices = c("euclidean",
<                                                                "maximum", "manhattan", "canberra", "binary",
<                                                                "minkowski", "user"))
---
>     if(!is.null(user_coord)){
>       shiny::updateSelectInput(session, "coord",
>                                choices = c("Pull", "p-val", "User"))
>       shiny::updateSelectInput(session, "coordA",
>                                choices = c("Pull", "p-val", "User"))
>       shiny::updateSelectInput(session, "coordB",
>                                choices = c("Pull", "p-val", "User"))
108,113c43,53
<     if(!is.null(space2)){
<       shiny::updateSelectizeInput(session,"space1",choices = numeric.colnames, selected = df.colnames)
<       shiny::updateSelectizeInput(session,"space2",choices = numeric.colnames, selected = space2.colnames)
<     } else {
<       shiny::updateSelectizeInput(session,"space1",choices = numeric.colnames)
<       shiny::updateSelectizeInput(session,"space2",choices = numeric.colnames)
---
>
>     if(!is.null(user_dist)){
>       shiny::updateSelectInput(session, "metric",
>                                choices = c("euclidean", "maximum", "manhattan", "canberra",
>                                            "binary", "minkowski", "user"))
>       shiny::updateSelectInput(session, "metricA",
>                                choices = c("euclidean", "maximum", "manhattan", "canberra",
>                                            "binary", "minkowski", "user"))
>       shiny::updateSelectInput(session, "metricB",
>                                choices = c("euclidean", "maximum", "manhattan", "canberra",
>                                            "binary", "minkowski", "user"))
115,122d54
<     shiny::updateSelectizeInput(session,"label",choices = lab.choice, selected = "label")
<     shiny::updateSelectInput(session,"coord_space1",choices = names(getCoords))
<     shiny::updateSelectInput(session,"coord_space2",choices = names(getCoords))
<     shiny::updateSelectInput(session,"coordA",choices = names(getCoords))
<     shiny::updateSelectInput(session,"coordB",choices = names(getCoords))
<     shiny::updateSelectInput(session,"algorithm1",choices = names(dimReduction))
<     shiny::updateSelectInput(session,"algorithm2",choices = names(dimReduction))
<     shiny::hideTab("navbar","1",session)
124,143c56,64
<     shiny::observeEvent(input$space1,{
<       shiny::updateSelectizeInput(session,"space2",choices = numeric.colnames[!(numeric.colnames %in% c(input$space1,input$group,input$label))], selected = input$space2)
<       shiny::updateSelectizeInput(session,"group",choices = c(choose="",group.choice[!(group.choice %in% c(input$space1,input$space2,input$label))]), selected = input$group)
<       shiny::updateSelectizeInput(session,"label",choices = lab.choice[!(lab.choice %in% c(input$space1,input$space2,input$group))], selected = input$label)
<     }, ignoreInit = T, ignoreNULL = F)
<     shiny::observeEvent(input$space2,{
<       shiny::updateSelectizeInput(session,"space1",choices = numeric.colnames[!(numeric.colnames %in% c(input$space2,input$group,input$label))], selected = input$space1)
<       shiny::updateSelectizeInput(session,"group",choices = c(choose="",group.choice[!(group.choice %in% c(input$space1,input$space2,input$label))]), selected = input$group)
<       shiny::updateSelectizeInput(session,"label",choices = lab.choice[!(lab.choice %in% c(input$space1,input$space2,input$group))], selected = input$label)
<     }, ignoreInit = T, ignoreNULL = F)
<     shiny::observeEvent(input$group,{
<       shiny::updateSelectizeInput(session,"space1",choices = numeric.colnames[!(numeric.colnames %in% c(input$space2,input$group,input$label))], selected = input$space1)
<       shiny::updateSelectizeInput(session,"space2",choices = numeric.colnames[!(numeric.colnames %in% c(input$space1,input$group,input$label))], selected = input$space2)
<       shiny::updateSelectizeInput(session,"label",choices = lab.choice[!(lab.choice %in% c(input$space1,input$space2,input$group))], selected = input$label)
<     }, ignoreInit = T, ignoreNULL = F)
<     shiny::observeEvent(input$label,{
<       shiny::updateSelectizeInput(session,"space1",choices = numeric.colnames[!(numeric.colnames %in% c(input$space2,input$group,input$label))], selected = input$space1)
<       shiny::updateSelectizeInput(session,"space2",choices = numeric.colnames[!(numeric.colnames %in% c(input$space1,input$group,input$label))], selected = input$space2)
<       shiny::updateSelectizeInput(session,"group",choices = c(choose="",group.choice[!(group.choice %in% c(input$space1,input$space2,input$label))]), selected = input$group)
<     }, ignoreInit = T, ignoreNULL = F)
---
>     shiny::observeEvent(c(input$metric, input$coord, input$useCov, input$linkage), {
>       n_points <- nrow(pred)
>       rv$coord <- getCoords(input$coord, input$useCov, pred, covInv, exp, user_coord)
>       dists <- getDists(rv$coord, input$metric, user_dist)
>       rv$d_mat <- as.matrix(dists)
>       rv$fit <- stats::hclust(dists, input$linkage)
>       rv$cstats <- getClusterStats(stats::as.dist(rv$d_mat), rv$fit, chi2, 8)
>     }, priority = 99
>     )
145,267c66
<     shiny::observeEvent(input$group,{
<       if (is.null(input$group)){
<         rv$tmp.group <- NULL
<         shinyFeedback::hideFeedback("group",session)
<       } else{
<         group.df <-
<           dplyr::bind_cols(
<             dplyr::select(df, tidyselect::any_of(input$group)),
<             if (!is.null(space2)) {dplyr::select(space2, tidyselect::any_of(input$group))},
<             if (!is.null(group)) {dplyr::select(group,  tidyselect::any_of(input$group))}
<           ) %>%
<           dplyr::select(tidyselect::all_of(input$group))
<
<         rv$temp.group <- interaction(group.df)
<         n.level <-nlevels(rv$temp.group)
<
<         if (n.level>12){
<           shinyFeedback::hideFeedback("group",session)
<           shinyFeedback::feedbackWarning("group", T, text = paste("number of groups made:",n.level,"WARNING max 12"), session = session)
<         } else {
<           shinyFeedback::hideFeedback("group",session)
<           shinyFeedback::feedbackSuccess("group", T, text = paste("number of groups made:",n.level), session = session)
<         }
<       }
<     }, ignoreNULL = F)
<
<     shiny::observeEvent(input$app.load,{
<       rv$space1 <-
<         dplyr::bind_cols(
<           dplyr::select(df,     tidyselect::any_of(input$space1)),
<           if (!is.null(space2)) {dplyr::select(space2, tidyselect::any_of(input$space1))}
<         ) %>%
<         dplyr::select(tidyselect::all_of(input$space1))
<
<       rv$space2 <-
<         dplyr::bind_cols(
<           dplyr::select(df,     tidyselect::any_of(input$space2)),
<           if (!is.null(space2)) {dplyr::select(space2, tidyselect::any_of(input$space2))}
<         ) %>%
<         dplyr::select(tidyselect::all_of(input$space2))
<
<       if(all(input$label!="")){
<         if (input$label == "label"){
<           rv$label <- as.vector(as.matrix(label))
<         } else {
<             rv$label <-
<               dplyr::bind_cols(
<                 dplyr::select(df,     tidyselect::any_of(input$label)),
<                 if (!is.null(space2)) {dplyr::select(space2, tidyselect::any_of(input$label))}
<               )
<           }
<
<       }else{ rv$label <- ""}
<
<       if (all(input$space1 %in% df.colnames) & !is.null(cov)){
<         space1.filt <- which(df.colnames %in% input$space1)
<         rv$cov1  <- cov[space1.filt,space1.filt]
<       } else {
<         rv$cov1 <- cov(rv$space1)
<       }
<
<       if (is.inv & setequal(df.colnames,input$space1)) {rv$covInv1 <- covInv}
<       else {rv$covInv1 <- try(solve(rv$cov1))}
<
<       if (all(input$space2 %in% df.colnames)){
<         space2.filt <- which(space2.colnames %in% input$space2)
<         rv$cov2  <- cov[space2.filt,space2.filt]
<       } else {
<         rv$cov2 <- cov(rv$space2)
<       }
<       rv$covInv2 <- try(solve(rv$cov2))
<
<       if (is.null(input$group)){
<         rv$colour.choice <- intersect(rv$colour.choice,c("clustering","score","bins"))
<         shiny::updateCheckboxInput(session,"usegroupB", value = F)
<
<       } else{
<         rv$colour.choice <- unique(c(rv$colour.choice,"user"))
<       }
<
<       rv$load.app <- TRUE
<
<       rv$ndf <- ncol(rv$space2)
<       rv$cond <- 1:n
<       if (setequal(df.colnames,input$space1) & !is.null(exp)) {
<         rv$exp <- data.frame(value = exp)
<       } else if (all(input$space1 %in% df.colnames) & !is.null(exp)){
<           rv$exp <- data.frame(value = exp[space1.filt,])
<       } else {
<           rv$exp <- data.frame(value = colMeans(rv$space1))
<       }
<       if (setequal(space2.colnames,input$space2) & !is.null(space2.exp)) {
<         rv$exp2 <- data.frame(value = space2.exp)
<       } else if (all(input$space1 %in% df.colnames) & !is.null(space2.exp)){
<         rv$exp2 <- data.frame(value = space2.exp[space2.filt,])
<       } else {
<         rv$exp2 <- data.frame(value = colMeans(rv$space2))
<       }
<       rv$user.group <- rv$temp.group
<       if (!is.null(rv$user.group)){
<         rv$user.pal <- RColorBrewer::brewer.pal(nlevels(rv$user.group), "Set3")
<         rv$pcol <- rv$user.pal[rv$user.group]
<       }
<       shiny::updateSelectInput(session,"px", choices = input$space2)
<       shiny::updateSelectInput(session,"py", choices = input$space2, selected = input$space2[2])
<       shiny::updateSelectInput(session,"pxA", choices = input$space2)
<       shiny::updateSelectInput(session,"pyA", choices = input$space2, selected = input$space2[2])
<       shiny::updateSelectInput(session,"pxB", choices = input$space2)
<       shiny::updateSelectInput(session,"pyB", choices = input$space2, selected = input$space2[2])
<
<       rv$space1names <- input$space1
<       rv$space2names <- input$space2
<
<       rv$coord1 <- try(getCoords[[input$coord_space1]](df=rv$space1, cov=rv$cov1, covInv=rv$covInv1, exp=rv$exp))
<       rv$coord2 <- try(getCoords[[input$coord_space2]](df=rv$space2, cov=rv$cov2, covInv=rv$covInv2, exp=rv$exp2))
<       shiny::showTab("navbar","1",select = TRUE,session)
<
<     }, priority = 1)
<
<     shiny::observeEvent(c(input$metric, rv$coord1, rv$coord2,
<                           input$linkage, rv$space1, rv$space2, input$kC,
<                           input$app.load), {
<       shiny::req(rv$load.app)
---
>     shiny::observeEvent(c(input$kC, rv$fit), {
269,295c68
<       if (!is.null(getScore)){
<         rv$value<- getScore(space1=rv$space1, cov=rv$cov1, covinv=rv$covInv1, exp=rv$exp, space2=rv$space2, space2.cov=rv$cov2, space2.exp=rv$space2.exp, k=rv$kC)
<         if (!is.null(rv$value$score)){
<           rv$scorecol <- viridis::viridis(n)[rank(rv$value$score)]
<           rv$colour.choice <- unique(c(rv$colour.choice,"score"))
<         }
<         if(!is.null(rv$value$bins)){
<           rv$palSig <- RColorBrewer::brewer.pal(length(unique(rv$value$bins)), "Set2")
<           rv$colSig <- rv$palSig[rv$value$bins]
<           rv$colour.choice <- unique(c(rv$colour.choice,"bins"))
<         }
<         }
<
<       dists1 <- tryCatch(getDists(rv$coord1, input$metric, user_dist), error = function(e){
<         warning("Distances have failed to calculate, coordinates may not have been calculated", call. = F)
<       })
<       rv$d_mat <- as.matrix(dists1)
<
<       dists2 <- tryCatch(getDists(rv$coord2, input$metric, NULL), error = function(e){
<         warning("Distances have failed to calculate, coordinates may not have been calculated", call. = F)
<       })
<       rv$d_mat2 <- as.matrix(dists2)
<
<
<       rv$fit <- stats::hclust(dists1, input$linkage)
<       rv$cstats <- getClusterStats(dists1,rv$fit, computeChi2(rv$space1, rv$covInv1, rv$exp), 8)
<       groups <- stats::cutree(rv$fit, k = rv$kC)
---
>       groups <- stats::cutree(rv$fit, k=rv$kC)
297,298c70
<       rv$groups <- as.numeric(factor(groups, levels = rv$lvl))
<       shiny::updateSelectizeInput(session,"pc.filt",choices = unique(rv$groups),selected = unique(rv$groups))
---
>       rv$groups <- as.numeric(factor(groups, levels= rv$lvl))
300a73
>       rv$sigmabins <- chi2bins(chi2, ndf, rv$kC)
302,303d74
<       a <- round(max(c(rv$benchmarks$r,0.1)),1)
<       shiny::updateSliderInput(session,"alpha", max = a, value = a/2, step = a/100)
306,315c77,83
<       rv$pointcol[rv$value$is.interest] <- "black"
<       rv$pch <- rep(1, n)
<       rv$pch[rv$value$is.interest] <- 2
<     }, priority = 80, ignoreInit = T)
<     shiny::observeEvent(rv$colour.choice,{
<       shiny::updateSelectInput(session,"colouring1","Colouring", choices = rv$colour.choice)
<       shiny::updateSelectInput(session,"colouring2","Colouring", choices = rv$colour.choice)
<       shiny::updateSelectInput(session,"dimred.colour1","Colouring", choices = rv$colour.choice)
<       shiny::updateSelectInput(session,"dimred.colour2","Colouring", choices = rv$colour.choice)
<     }, priority = -1)
---
>       rv$pointcol[c(sm,bf)] <- "black"
>       rv$pch <- rep(20, n)
>       rv$pch[sm] <- 8
>       rv$pch[bf] <- 15
>       rv$alpha <- rep(0.6, n)
>       rv$alpha[c(sm,bf)] <- 1
>     }, priority = 80)
316a85,115
>     shiny::observeEvent(c(input$px, input$py),{
>       rv$x <- input$px
>       rv$y <- input$py
>       add_params <- colnames(wc)[!colnames(wc) %in% c(rv$x, rv$y)]
>       if(length(add_params) > 0) {
>         rv$pz1 <- add_params[1]
>         output$conditions1 <- shiny::renderUI(
>           shiny::selectInput("vz1", label = add_params[1],
>                              choices = unique(wc[[add_params[1]]]))
>         )
>       }
>       if(length(add_params) > 1) {
>         rv$pz2 <- add_params[2]
>         output$conditions2 <- shiny::renderUI(
>           shiny::selectInput("vz2", label = add_params[2],
>                              choices = unique(wc[[add_params[2]]]))
>         )
>       }
>       else rv$pz2 <- NULL
>     })
>
>
>     shiny::observeEvent(c(input$vz1, input$vz2), {
>       rv$cond1 <- which(wc[[rv$pz1]]==as.numeric(input$vz1))
>       if(! is.null(rv$pz2)){
>         rv$cond2 <- which(wc[[rv$pz2]]==as.numeric(input$vz2))
>         rv$cond <- intersect(rv$cond1, rv$cond2)
>       }
>       else rv$cond <- rv$cond1
>     })
>
318d116
<       shiny::req(rv$load.app)
320c118,119
<     }, height = 325)
---
>       }, height = 325)
>
322,323c121
<       shiny::req(rv$load.app,rv$value)
<       plotChi2(rv$space2, rv$value$score, input$px, input$py, rv$value$scoreName, rv$cond)
---
>       plotChi2(wc, chi2, rv$x, rv$y, rv$cond)
324a123
>
326,332c125,132
<       shiny::req(rv$load.app)
<       rv$cstats %>% tidyr::pivot_longer(cols = .data$within.cluster.ss:.data$dmin,
<                                         names_to = "stat") %>%
<         ggplot2::ggplot() + ggplot2::geom_line(ggplot2::aes(x = .data$k, y = .data$value)) +
<         ggplot2::xlab("# clusters") + ggplot2::ylab("") +
<         ggplot2::facet_wrap(~stat, ncol = 3, scales = "free_y",
<                             labeller = cstat_labeller()) + ggplot2::theme_bw()
---
>       rv$cstats %>%
>         tidyr::pivot_longer(cols=within.cluster.ss:dmin, names_to="stat") %>%
>         ggplot2::ggplot() +
>         ggplot2::geom_line(ggplot2::aes(x=k, y=value)) +
>         ggplot2::xlab("# clusters") +
>         ggplot2::ylab("") +
>         ggplot2::facet_wrap(~stat, ncol=3, scales = "free_y", labeller=cstat_labeller()) +
>         ggplot2::theme_bw()
333a134
>
335,347c136,149
<       shiny::req(rv$load.app)
<       dat <- rv$coord1[rv$cond, ]
<       dat %>% tourr::rescale() %>% tibble::as_tibble() %>%
<         cbind(rv$space2[rv$cond, ]) %>%
<         tidyr::pivot_longer(cols = rv$space1names,
<                             names_to = "observable") %>%
<         dplyr::mutate(observable = factor(.data$observable,
<                                           levels = rv$space1names)) %>%
<         ggplot2::ggplot(ggplot2::aes_string(input$px,input$py, color = "value")) +
<         ggplot2::geom_point() +
<         ggplot2::facet_wrap(~observable, scales = "free",
<                             ncol = 7) + ggplot2::guides(colour = "none") +
<         ggplot2::scale_colour_viridis_c() + ggplot2::theme_bw() +
---
>       dat <- rv$coord[rv$cond,]
>       colnames(dat) <- paste0("O",1:ncol(pred))
>       dat %>%
>         tourr::rescale() %>%
>         tibble::as_tibble() %>%
>         cbind(wc[rv$cond,]) %>%
>         tidyr::pivot_longer(cols = tidyselect::starts_with("O"), names_to="observable") %>%
>         dplyr::mutate(observable = factor(observable, levels = paste0("O",1:ncol(pred)))) %>%
>         ggplot2::ggplot(ggplot2::aes_string(rv$x, rv$y, fill="value")) +
>         ggplot2::geom_tile() +
>         ggplot2::facet_wrap(~observable, scales = "free", ncol=7) +
>         ggplot2::guides(fill = FALSE) +
>         ggplot2::scale_fill_viridis_c() +
>         ggplot2::theme_bw() +
350a153
>
352,354c155,161
<       shiny::req(rv$load.app)
<       plotPC(rv$coord1, rv$groups, rv$benchmarks$id, input$pc.filt, input$pc.centre, input$pc.scale, a=0.2, rv$pal)
<     })
---
>       plotPC(rv$coord, rv$groups, rv$benchmarks$id)
>     }, height = 300)
>
>     output$pc2 <- shiny::renderPlot({
>       plotPC(rv$coord, rv$groups, rv$benchmarks$id, TRUE)
>     }, height = 300)
>
356,359c163,166
<       shiny::req(rv$load.app)
<       plotWC(rv$space2, input$px, input$py, rv$value$is.interest, rv$benchmarks$id,
<                 rv$col, rv$cond, groups = rv$groups, pal = rv$pal, a = input$alpha, showalpha = input$plotHulls)
<     }, height = 325)
---
>       plotWC(wc, rv$x, rv$y, sm, bf, rv$benchmarks$id, rv$col, rv$cond)
>       }, height = 325)
>
>
361,363c168,170
<       shiny::req(rv$load.app,rv$value)
<       plotSigBin(rv$space2, rv$value$is.interest, rv$benchmarks$id, rv$value$bins,
<                     input$px, input$py, rv$value$binName, rv$cond, "Set2")
---
>       plotSigBin(wc, sm, bf, rv$benchmarks$id, rv$sigmabins,
>                  rv$x, rv$y, rv$cond)
>
365,410d171
<     output$distText <- shiny::renderText(
<       paste0("Average distance: ",round(mean(as.vector(rv$d_mat)), 1),
<              ", Maximum distance: ",round(max(as.vector(rv$d_mat)), 1))
<       )
<     output$hist <- shiny::renderPlot({
<       shiny::req(rv$load.app)
<       groups<-rv$groups
<       dist_vec <- as.vector(rv$d_mat)
<       gr1 <- rep(groups,each = n)
<       gr2 <- rep(groups,times = n)
<       dist_tib <- tibble::tibble(dist = dist_vec,gr1 = as.factor(gr1), gr2 = as.factor(gr2)) %>%
<         dplyr::mutate(match = dplyr::if_else(gr1 == gr2, "within", "between"))
<       ggplot2::ggplot(dist_tib,
<                             ggplot2::aes(x = .data$dist, y = ggplot2::after_stat(.data$density*.data$width))) +
<         ggplot2::geom_histogram(data = dplyr::select(dist_tib, -gr1, -gr2, -match),
<                                 fill = NA, color = "grey",position = "identity") +
<         ggplot2::geom_histogram(mapping = ggplot2::aes(color = gr1),
<                                 fill = NA, position = "identity") +
<         ggplot2::scale_color_brewer(palette = "Dark2") +
<         ggplot2::facet_grid(gr1 ~ match) + ggplot2::theme_bw() +
<         ggplot2::xlab("") + ggplot2::ylab("") + ggplot2::ggtitle("Distribution of distances within and between clusters") +
<         ggplot2::theme(legend.position = "none", strip.text.y = ggplot2::element_blank())
<     })
<     output$benchmarks = DT::renderDT({
<       shiny::req(rv$load.app)
<       dt <- rv$space2[rv$benchmarks$id, ] %>% tibble::add_column(cluster = rv$benchmarks$group) %>%
<         tibble::add_column(r = rv$benchmarks$r) %>% tibble::add_column(d = rv$benchmarks$d) %>%
<         tibble::add_column(score = rv$value$score[rv$benchmarks$id])
<       DT::formatRound(DT::datatable(dt[, c(rv$ndf + 1,
<                                            1:rv$ndf, (rv$ndf + 2):ncol(dt))], rownames = FALSE),
<                       2:ncol(dt), digits = 2) %>% DT::formatStyle("cluster",
<                                                                   backgroundColor = DT::styleEqual(rv$benchmarks$group,
<                                                                                                    unique(rv$col)))
<     })
<     output$benchmarks.grouping <- DT::renderDT({
<       shiny::req(rv$load.app)
<       group.benchmarks <- getBenchmarkInformation(rv$d_mat, as.numeric(rv$user.group))
<       dt <- rv$space2[group.benchmarks$id, ] %>% tibble::add_column(cluster = unique(as.character(rv$user.group))) %>%
<         tibble::add_column(r = group.benchmarks$r) %>% tibble::add_column(d = group.benchmarks$d) %>%
<         tibble::add_column(score = rv$value$score[group.benchmarks$id])
<       DT::formatRound(DT::datatable(dt[, c(rv$ndf + 1,
<                                            1:rv$ndf, (rv$ndf + 2):ncol(dt))], rownames = FALSE),
<                       2:ncol(dt), digits = 2) %>% DT::formatStyle("cluster",
<                                                                   backgroundColor = DT::styleEqual(unique(as.character(rv$user.group)),
<                                                                                                    unique(rv$pcol)))
<     })
412,444c173,176
<     #tour options
<     shiny::observeEvent(c(input$colouring1,rv$groups,rv$user.group,rv$value$score),{
<       rv$tour1<- colourHelper(input$colouring1,rv)
<     })
<     shiny::observeEvent(c(input$colouring2,rv$groups,rv$user.group,rv$value$score),{
<       rv$tour2<- colourHelper(input$colouring2,rv)
<     })
<     shiny::observeEvent(c(input$tour1data,rv$space1names,rv$space2names),{
<       rv$tour1projection <- switch(input$tour1data,
<                                    "space1" = rv$space1names,
<                                    "space2" = rv$space2names,
<                                    "space1 PCA" = paste0("pc", 1:min(5, ncol(rv$space1))),
<                                    "space2 PCA" = paste0(" pc", 1:min(5, ncol(rv$space2))))
<       shiny::updateSelectInput(session,"select_radial_obs",choices = rv$tour1projection, selected = rv$tour1projection[[1]])
<       rv$tour1data       <- switch(input$tour1data,
<                                    "space1" = rv$coord1,
<                                    "space2" = rv$coord2,
<                                    "space1 PCA" = rv$pca1,
<                                    "space2 PCA" = rv$pca2)
<     },priority = 1)
<     shiny::observeEvent(c(input$tour2data,rv$space1names,rv$space2names),{
<       rv$tour2projection <- switch(input$tour2data,
<                                    "space1" = rv$space1names,
<                                    "space2" = rv$space2names,
<                                    "space1 PCA" = paste0("pc", 1:min(5, ncol(rv$space1))),
<                                    "space2 PCA" = paste0(" pc", 1:min(5, ncol(rv$space2))))
<       shiny::updateSelectInput(session,"select_radial_par",choices = rv$tour2projection, selected = rv$tour2projection[[1]])
<       rv$tour2data       <- switch(input$tour2data,
<                                    "space1" = rv$coord1,
<                                    "space2" = rv$coord2,
<                                    "space1 PCA" = rv$pca1,
<                                    "space2 PCA" = rv$pca2)
<     },priority = 1)
---
>     output$distText <- shiny::renderText(paste0("Average distance: ",
>                                          round(mean(as.vector(rv$d_mat)),1),
>                                          ", Maximum distance: ",
>                                          round(max(as.vector(rv$d_mat)), 1)))
446,467d177
<     shiny::observeEvent(c(input$render1),{
<       if (input$render1 == "2D"){
<         rv$tour.dim1 <- 2
<         shiny::updateSelectInput(session,"tour_type_obs", choices =
<                                    c("grand","cmass","holes","lda","pda","dcor","spline","radial","anomaly"))
<       } else {
<         rv$tour.dim1 <- 3
<         shiny::updateSelectInput(session,"tour_type_obs", choices =
<                                    c("grand","cmass","holes","lda","pda","dcor"))
<       }
<     },priority = 1)
<     shiny::observeEvent(c(input$render2),{
<       if (input$render2 == "2D"){
<         rv$tour.dim2 <- 2
<         shiny::updateSelectInput(session,"tour_type_param", choices =
<                                    c("grand","cmass","holes","lda","pda","dcor","spline","radial","anomaly"))
<       } else {
<         rv$tour.dim2 <- 3
<         shiny::updateSelectInput(session,"tour_type_param", choices =
<                                    c("grand","cmass","holes","lda","pda","dcor"))
<       }
<     },priority = 1)
469,486c179,194
<     shiny::observeEvent(c(input$radial_start_par, rv$space1_tour, input$slice_par,input$tour_type_param,rv$tour2data,rv$tour2,rv$tour1),{
<       if (input$tour_type_param == "radial"){
<         if (input$radial_start_par == "random") {
<           rv$radial_view_par <- tourr::basis_random(length(rv$tour2projection))
<         }else {
<           radial_tour_par <- switch(input$radial_start_par,
<                                     "cmass"  = tourr::guided_tour(tourr::cmass()),
<                                     "holes"  = tourr::guided_tour(tourr::holes()),
<                                     "lda"    = tourr::guided_tour(tourr::lda_pp(rv$tour2$colour)),
<                                     "pda"    = tourr::guided_tour(tourr::pda_pp(rv$tour2$colour)),
<                                     "dcor"   = tourr::guided_tour(tourr::dcor2d()),
<                                     "spline" = tourr::guided_tour(tourr::splines2d()),
<           )
<           hist <- tourr::save_history(rv$tour2data, tour_path = radial_tour_par, max_bases = 1000)
<           view <- drop(hist[,,dim(hist)[3]])
<           attr(view,"class") <- NULL
<           attr(view,"data")  <- NULL
<           rv$radial_view_par <- view
---
>     output$hist <- shiny::renderPlot({
>
>       # to get vector of distances without double-counting we
>       # transform to distance keeping only entries below the diagonal
>       dist_vec <- as.vector(rv$d_mat)
>       gr1 <- double(length(dist_vec))
>       gr2 <- double(length(dist_vec))
>       diff_m <- matrix(nrow = length(dist_vec), ncol = ncol(pred))
>       ctr <- 1
>       #FIXME faster implementation of this?
>       for(i in 1:n){
>         for(j in 1:n){
>           gr1[ctr] <- rv$groups[i]
>           gr2[ctr] <- rv$groups[j]
>           diff_m[ctr,] <- rv$coord[i,] - rv$coord[j,]
>           ctr <- ctr + 1
489,580d196
<     },priority = 1)
<     shiny::observeEvent(c(input$radial_start_obs, rv$space1_tour, input$slice_obs,input$tour_type_obs,rv$tour1data,rv$tour1,rv$tour2),{
<       if (input$tour_type_obs=="radial"){
<         if (input$radial_start_obs == "random") {
<           rv$radial_view_obs <- tourr::basis_random(length(rv$tour1projection))
<         }else {
<           radial_tour_obs <- switch(input$radial_start_obs,
<                                     "cmass"  = tourr::guided_tour(tourr::cmass()),
<                                     "holes"  = tourr::guided_tour(tourr::holes()),
<                                     "lda"    = tourr::guided_tour(tourr::lda_pp(rv$tour1$colour)),
<                                     "pda"    = tourr::guided_tour(tourr::pda_pp(rv$tour1$colour)),
<                                     "dcor"   = tourr::guided_tour(tourr::dcor2d()),
<                                     "spline" = tourr::guided_tour(tourr::splines2d()),
<           )
<           hist <- tourr::save_history(rv$tour1data, tour_path = radial_tour_obs, max_bases = 1000)
<           view <- drop(hist[,,dim(hist)[3]])
<           attr(view,"class") <- NULL
<           attr(view,"data")  <- NULL
<           rv$radial_view_obs <- view
<         }
<       }
<     },priority = 1)
<     shiny::observeEvent(c(input$tour_type_param, input$select_radial_par,input$ellc_param,rv$radial_view_par,rv$tour2projection,rv$tour.dim2), {
<       if (is.null(input$select_radial_par)){
<         rad.var<-1
<         shinyFeedback::feedbackWarning("select_radial_par", T, text = "Warning: a radial variable must be selected", session = session)
<         rv$radialWarn <- rv$radialWarn+1
<       }else{
<         rad.var <- which(rv$tour2projection %in% input$select_radial_par)
<         shinyFeedback::hideFeedback("select_radial_par", session = session)
<       }
<       rv$paramType <- switch(input$tour_type_param,
<                              "grand"  = tourr::grand_tour(rv$tour.dim2),
<                              "cmass"  = tourr::guided_tour(tourr::cmass(),rv$tour.dim2),
<                              "holes"  = tourr::guided_tour(tourr::holes(),rv$tour.dim2),
<                              "lda"    = tourr::guided_tour(tourr::lda_pp(rv$tour2$colour),rv$tour.dim2),
<                              "pda"    = tourr::guided_tour(tourr::pda_pp(rv$tour2$colour),rv$tour.dim2),
<                              "dcor"   = tourr::guided_tour(tourr::dcor2d(),rv$tour.dim2),
<                              "spline" = tourr::guided_tour(tourr::splines2d(),rv$tour.dim2),
<                              "radial" = tourr::radial_tour(rv$radial_view_par, rad.var),
<                              "anomaly"= tourr::guided_anomaly_tour(tourr::anomaly_index(),ellipse = rv$cov2, ellc=as.numeric(input$ellc_param))
<       )
<       rv$detour2.angles <- if (input$tour_type_param == "radial") 1 / 2 else 1
<       rv$tour_bases1 <- if(input$tour_type_param %in% c("cmass","holes","lda","pda","dcor","spline","anomaly")) 1000 else 20
<     },priority = 1)
<     shiny::observeEvent(c(input$tour_type_obs,input$select_radial_obs,input$ellc_obs,rv$radial_view_obs,rv$tour1projection,rv$tour.dim1),{
<       if (is.null(input$select_radial_obs)){
<         rad.var<-1
<         shinyFeedback::feedbackWarning("select_radial_obs", T, text = "Warning: a radial variable must be selected", session = session)
<         rv$radialWarn <- rv$radialWarn+1
<       }else{
<         rad.var <- which(rv$tour1projection %in% input$select_radial_obs)
<         shinyFeedback::hideFeedback("select_radial_obs", session = session)
<       }
<       rv$obsType <- switch(input$tour_type_obs,
<                            "grand"  = tourr::grand_tour(rv$tour.dim1),
<                            "cmass"  = tourr::guided_tour(tourr::cmass(),rv$tour.dim1),
<                            "holes"  = tourr::guided_tour(tourr::holes(),rv$tour.dim1),
<                            "lda"    = tourr::guided_tour(tourr::lda_pp(rv$tour1$colour),rv$tour.dim1),
<                            "pda"    = tourr::guided_tour(tourr::pda_pp(rv$tour1$colour),rv$tour.dim1),
<                            "dcor"   = tourr::guided_tour(tourr::dcor2d(),rv$tour.dim1),
<                            "spline" = tourr::guided_tour(tourr::splines2d(),rv$tour.dim1),
<                            "radial" = tourr::radial_tour(rv$radial_view_obs, rad.var),
<                            "anomaly"= tourr::guided_anomaly_tour(tourr::anomaly_index(), ellipse = rv$cov1, ellc = as.numeric(input$ellc_obs))
<       )
<       rv$detour1.angles <- if (input$tour_type_obs == "radial") 1 / 2 else 1
<       rv$tour_bases2 <- if(input$tour_type_obs %in% c("cmass","holes","lda","pda","dcor","spline","anomaly")) 1000 else 20
<     },priority = 1)
<     shiny::observeEvent(c(input$slice_obs,input$slw_obs,rv$space1_tour,input$ellc_obs,rv$ell_obs,rv$tour1),{
<       if (input$slice_obs) {
<         rv$displayobs <- function(x){
<           return(detourr::show_slice(x, palette = rv$tour1$pal, slice_relative_volume = as.numeric(input$slw_obs)))
<         }
<       }
<       else {
<         rv$displayobs <- function(x){
<           return(detourr::show_scatter(x, palette = rv$tour1$pal, alpha=0.6)) # pch = rv$space1_tour$pch, ellipse = rv$ell_obs, ellc = as.numeric(input$ellc_obs)
<         }
<       }
<     })
<     shiny::observeEvent(c(input$slice_par,input$slw_par,rv$space1_tour,input$ellc_param,rv$ell_par,rv$tour2),{
<       if(input$slice_par){
<         rv$displayparam <- function(x){
<           return(detourr::show_slice(x, palette = rv$tour2$pal, slice_relative_volume = as.numeric(input$slw_par)))
<         }
<       }
<       else {
<         rv$displayparam <- function(x){
<           return(detourr::show_scatter(x, palette = rv$tour2$pal, alpha=0.6)) # pch = rv$space2_tour$pch, ellipse = rv$ell_par, ellc = as.numeric(input$ellc_param)
<         }
<       }
<     })
582,588c198
<     #dimension reduction options
<     shiny::observeEvent(c(input$dimred.colour1,rv$groups,rv$user.group,rv$value$score),{
<       rv$dimRed1<- colourHelper(input$dimred.colour1,rv)
<     })
<     shiny::observeEvent(c(input$dimred.colour2,rv$groups,rv$user.group,rv$value$score),{
<       rv$dimRed2<- colourHelper(input$dimred.colour2,rv)
<     })
---
>       colnames(diff_m) <- paste0("diff_",1:ncol(pred))
589a200,202
>       dist_tib <- tibble::as_tibble(diff_m) %>%
>         dplyr::mutate(dist = dist_vec, gr1 = as.factor(gr1), gr2 = as.factor(gr2)) %>%
>         dplyr::mutate(match = dplyr::if_else(gr1==gr2, "within", "between"))
591,601c204,219
<     shiny::observeEvent(c(rv$coord1,rv$coord2,input$algorithm1,input$red1.data),{
<       shiny::req(rv$load.app)
<       if ((input$algorithm1==input$algorithm2)&&(input$red1.data==input$red2.data)){
<         rv$coord_red1 <- rv$coord_red2
<       } else {
<         if(input$red1.data=="space1"){
<           rv$coord_red1 <- try(dimReduction[[input$algorithm1]](mat = rv$coord1, dist = rv$d_mat))
<         } else {
<           rv$coord_red1 <- try(dimReduction[[input$algorithm1]](mat = rv$coord2, dist = rv$d_mat2))
<         }
<       }
---
>       p1 <- ggplot2::ggplot(dist_tib,
>                             ggplot2::aes(x = dist, y = stat(count / sum(count)))) +
>         ggplot2::geom_histogram(data=dplyr::select(dist_tib, -gr1, -gr2, -match),
>                                 fill=NA, color="grey", position="identity") +
>         ggplot2::geom_histogram(mapping = ggplot2::aes(color= gr1),
>                                 fill=NA, position="identity") +
>         ggplot2::scale_color_brewer(palette="Dark2") +
>         ggplot2::facet_grid(gr1~match) +
>         ggplot2::theme_bw() +
>         ggplot2::xlab("") +
>         ggplot2::ylab("") +
>         ggplot2::ggtitle(
>           "Distribution of distances within and between clusters"
>           ) +
>         ggplot2::theme(legend.position = "none",
>                        strip.text.y = ggplot2::element_blank())
603,617c221,227
<       tryCatch(colnames(rv$coord_red1$Y) <- c("dim1A","dim2A"), error = function(e){
<         warning("dimension reduction has not returned correctly formatted data", call. = F)
<       })
<     },ignoreInit = T)
<     shiny::observeEvent(c(rv$coord1,rv$coord2,input$algorithm2,input$red2.data),{
<       shiny::req(rv$load.app)
<       if ((input$algorithm1==input$algorithm2)&&(input$red1.data==input$red2.data)){
<         rv$coord_red2 <- rv$coord_red1
<       } else {
<         if(input$red2.data=="space1"){
<           rv$coord_red2 <- try(dimReduction[[input$algorithm2]](mat = rv$coord1, dist = rv$d_mat))
<         } else {
<           rv$coord_red2 <- try(dimReduction[[input$algorithm2]](mat = rv$coord2, dist = rv$d_mat2))
<         }
<       }
---
>       dist_long <- dist_tib %>%
>         dplyr::select(-dist) %>%
>         tidyr::pivot_longer(cols = tidyselect::starts_with("diff"),
>                             names_to="observable", values_to="difference",
>                             names_prefix = "diff_")
>       dist_long$observable <- factor(as.integer(dist_long$observable),
>                                      levels=1:ncol(pred))
619,622c229,242
<       tryCatch(colnames(rv$coord_red2$Y) <- c("dim1B","dim2B"), error = function(e){
<         warning("dimension reduction has not returned correctly formatted data", call. = F)
<       })
<     },ignoreInit = T)
---
>       p2 <-  ggplot2::ggplot(dist_long,
>                              ggplot2::aes( x = gr1, y = difference,
>                                            color = gr1, fill = match)) +
>         ggplot2::geom_boxplot() +
>         ggplot2::scale_color_brewer(palette="Dark2") +
>         ggplot2::scale_fill_manual(values = c("grey", "white")) +
>         ggplot2::facet_wrap(.~observable, ncol = 3) +
>         ggplot2::theme_bw() +
>         ggplot2::xlab("") +
>         ggplot2::ylab("") +
>         ggplot2::ggtitle("Distribution of coordinate differences between (left)
>                          and within (right) clusters") +
>         ggplot2::theme(legend.position = "none",
>                        strip.text.y = ggplot2::element_blank())
624,629c244
<     shiny::observeEvent(c(rv$coord1,rv$coord2),{
<       rv$pca1 <- stats::prcomp(rv$coord1)$x[, 1:min(5,ncol(rv$space1))]
<       colnames(rv$pca1) <- paste0("pc", 1:min(5, ncol(rv$space1)))
<       rv$pca2 <- stats::prcomp(rv$coord2)$x[, 1:min(5,ncol(rv$coord2))]
<       colnames(rv$pca2) <- paste0(" pc", 1:min(5, ncol(rv$coord2)))
<     })
---
>      gridExtra::grid.arrange(p1, p2, ncol=2)
631,638d245
<     tour.data <- shiny::reactive({shiny::req(rv$coord1,rv$coord2)
<       data <- dplyr::bind_cols(rv$coord1,rv$coord2,rv$pca1,rv$pca2,rv$coord_red1$Y,rv$coord_red2$Y)
<       data$colour1<- rv$tour1$colour
<       data$colour2<- rv$tour2$colour
<       data$label1 <- rv$tour1$label
<       data$label2 <- rv$tour2$label
<       data
<     })
639a247
>     },height = 600, width = 1000)
641c249
<     shared.data <- crosstalk::SharedData$new(tour.data)
---
>     output$benchmarks = DT::renderDT({
642a251,255
>       dt <- wc[rv$benchmarks$id,] %>%
>         tibble::add_column(cluster = rv$benchmarks$group) %>%
>         tibble::add_column(r = rv$benchmarks$r) %>%
>         tibble::add_column(d = rv$benchmarks$d) %>%
>         tibble::add_column(sigma = sig[rv$benchmarks$id])
644,652c257,265
<     output$dimRed1 <- plotly::renderPlotly({
<       shiny::req(rv$load.app)
<       shiny::validate(
<         shiny::need(try(!is.null(shared.data$origData()[c("dim1A","dim2A")])),
<                     "data cannot be plotted select a different dimension reduction algorithm or data")
<       )
<       dim.title   <- paste(input$algorithm1, "embedding")
<       dim.axislab <- input$algorithm1
<       dim.text    <- rv$dimRed1$label
---
>       DT::formatRound(DT::datatable(
>         dt[,c(ncol(wc)+1, 1:ncol(wc), (ncol(wc)+2):ncol(dt))],
>         rownames = FALSE),
>         2:ncol(dt), digits=2) %>%
>         DT::formatStyle(
>           "cluster",
>           backgroundColor = DT::styleEqual(rv$benchmarks$group, unique(rv$col)))
>     }
>     )
654,663c267,277
<       plotly::plot_ly(shared.data, x = ~dim1A, y = ~dim2A,
<                       color = as.factor(rv$dimRed1$colour), symbol = rv$pch, symbols = c("circle","o"),
<                       text = dim.text, colors = rv$dimRed1$pal,
<                       marker = list(showscale = FALSE)) %>%
<         plotly::add_trace(type = "scatter", mode = "markers") %>%
<         plotly::layout(title = dim.title,
<                        xaxis = list(title = paste(dim.axislab,1), scaleanchor = "y", range = rv$lim),
<                        yaxis = list(title = paste(dim.axislab,2), range = rv$lim),
<                        showlegend = FALSE) %>%
<         plotly::highlight(on = "plotly_selected", off = "plotly_deselect", selected = plotly::attrs_selected(opacity=1))
---
>
>     output$tsne <- shiny::renderPlot({
>       dist_tsne <- Rtsne::Rtsne(rv$d_mat, is_distance=TRUE)$Y
>       colnames(dist_tsne) <- c("tsne1", "tsne2")
>       ggplot2::ggplot(tibble::as_tibble(dist_tsne),
>                       ggplot2::aes(tsne1, tsne2)) +
>         ggplot2::geom_point(size=3, color= rv$pointcol,
>                    shape=rv$pch, alpha=rv$alpha) +
>         ggplot2::theme_bw() +
>         ggplot2::ggtitle("t-SNE embedding") +
>         ggplot2::theme(aspect.ratio = 1, legend.position = "none")
666,685c280,289
<     output$dimRed2 <- plotly::renderPlotly({
<       shiny::req(rv$load.app)
<       shiny::validate(
<         shiny::need(try(!is.null(shared.data$origData()[c("dim1B","dim2B")])),
<                     "data cannot be plotted select a different dimension reduction algorithm or data")
<       )
<       dim.title   <- paste(input$algorithm2, "embedding")
<       dim.axislab <- input$algorithm2
<       dim.text    <- rv$dimRed2$label
<
<       plotly::plot_ly(shared.data, x = ~dim1B, y = ~dim2B,
<                       color = as.factor(rv$dimRed2$colour), symbol = rv$pch, symbols = c("circle","o"),
<                       text = dim.text, colors = rv$dimRed2$pal,
<                       marker = list(showscale = FALSE)) %>%
<         plotly::add_trace(type = "scatter", mode = "markers") %>%
<         plotly::layout(title = dim.title,
<                        xaxis = list(title = paste(dim.axislab,1), scaleanchor = "y", range = rv$lim),
<                        yaxis = list(title = paste(dim.axislab,2), range = rv$lim),
<                        showlegend = FALSE) %>%
<         plotly::highlight(on = "plotly_selected", off = "plotly_deselect", selected = plotly::attrs_selected(opacity=1))
---
>     output$umap <- shiny::renderPlot({
>       dist_umap <- as.matrix(uwot::umap(stats::as.dist(rv$d_mat)))
>       colnames(dist_umap) <- c("umap1", "umap2")
>       ggplot2::ggplot(tibble::as_tibble(dist_umap),
>                       ggplot2::aes(umap1, umap2)) +
>         ggplot2::geom_point(size=3, color= rv$pointcol,
>                    shape=rv$pch, alpha=rv$alpha) +
>         ggplot2::theme_bw() +
>         ggplot2::ggtitle("UMAP embedding") +
>         ggplot2::theme(aspect.ratio = 1, legend.position = "none")
688,691d291
<     output$tourImg1 <- detourr::shinyRenderDetour({
<       shiny::validate(
<         shiny::need(try(!is.null(shared.data$origData()[rv$tour1projection])),"data cannot be plotted select different data")
<       )
693,695c293,302
<       detourr::detour(shared.data, detourr::tour_aes(projection = tidyselect::all_of(rv$tour1projection), colour = "colour1", label = I(.data$label1))) %>% #.data may be deprecated in this way
<         detourr::tour_path(rv$obsType, fps = 60, aps = rv$detour1.angles, max_bases = rv$tour_bases2) %>%
<         rv$displayobs()
---
>     output$lle <- shiny::renderPlot({
>       dist_lle <- lle::lle(rv$coord, 2, 10)$Y
>       colnames(dist_lle) <- c("lle1", "lle2")
>       ggplot2::ggplot(tibble::as_tibble(dist_lle),
>                       ggplot2::aes(lle1, lle2)) +
>         ggplot2::geom_point(size=3, color= rv$pointcol,
>                    shape=rv$pch, alpha=rv$alpha) +
>         ggplot2::theme_bw() +
>         ggplot2::ggtitle("Local linear embedding") +
>         ggplot2::theme(aspect.ratio = 1, legend.position = "none")
697,704c304,316
<     output$tourImg2 <- detourr::shinyRenderDetour({
<       shiny::validate(
<         shiny::need(try(!is.null(shared.data$origData()[rv$tour2projection])),"data cannot be plotted select different data")
<       )
<       rv$detouring <- TRUE
<       detourr::detour(shared.data, detourr::tour_aes(projection = tidyselect::all_of(rv$tour2projection), colour = "colour2", label = I(.data$label2))) %>% #.data may be deprecated in this way
<         detourr::tour_path(rv$paramType, fps = 60, aps = rv$detour2.angles, max_bases = rv$tour_bases1) %>%
<         rv$displayparam()
---
>
>     shiny::observeEvent(rv$groups,{
>       tour_data <- tour_coord(rv$coord, rv$pointcol, rv$pch)
>       tourr::render(tour_data$coord, tourr::grand_tour(),
>                     tourr::display_xy(col = tour_data$col, pch = tour_data$pch),
>                     'png', paste0(tmp, "/tour-%03d.png"),
>                     frames = 100, rescale = F)
>       dist_pca <- stats::prcomp(rv$coord)$x[,1:min(5, ncol(pred))]
>       colnames(dist_pca) <- paste0("pc",1:min(5, ncol(pred)))
>       tourr::render(dist_pca, tourr::grand_tour(),
>                     tourr::display_xy(col = rv$pointcol, pch = rv$pch),
>                     'png', paste0(tmp, "/tour-pca-%03d.png"),
>                     frames = 100, rescale = F)
707,710d318
<     shiny::observeEvent(rv$detouring,{
<       shiny::outputOptions(output, "tourImg1", suspendWhenHidden = FALSE)
<       shiny::outputOptions(output, "tourImg2", suspendWhenHidden = FALSE)
<     }, once = TRUE, ignoreInit = TRUE)
712,717c320
<     shiny::observeEvent(c(input$metric,input$linkage,input$kC,input$usemainA),{
<       shiny::req(input$usemainA)
<       shiny::updateSelectInput(session,"metricA",selected = input$metric)
<       shiny::updateSelectInput(session,"linkageA",selected = input$linkage)
<       shiny::updateSelectInput(session,"kA",selected = input$kC)
<     })
---
>     output$tourImg <- shiny::renderImage({
719,723c322,344
<     shiny::observeEvent(c(input$metricA, input$linkageA,
<                           input$linkageB, input$metricB,
<                           input$coordA, input$coordB,
<                           input$kA, input$kB, rv$space1),{
<       shiny::req(rv$load.app)
---
>       filename <- sprintf(paste0(tmp, '/tour-%03d.png'), input$n)
>       # Return a list containing the filename and alt text
>       list(src = filename,
>            width = 400,
>            height = 400,
>            alt = paste("Parameter space", input$n))},
>       deleteFile = FALSE)
>
>     output$tourImgPca <- shiny::renderImage({
>
>       filename <- sprintf(paste0(tmp, '/tour-pca-%03d.png'), input$npca)
>       # Return a list containing the filename and alt text
>       list(src = filename,
>            width = 400,
>            height = 400,
>            alt = paste("Parameter space", input$n))},
>       deleteFile = FALSE)
>
>
>     shiny::observeEvent(c(input$metricA, input$linkageA, input$linkageB, input$metricB,
>                           input$coordA, input$coordB, input$kA, input$kB, input$useCovA,
>                           input$useCovB), {
>
726,727c347,351
<       coordA <- getCoords[[input$coordA]](df=rv$space1, cov=rv$cov1, covInv=rv$covInv1, exp=rv$exp)
<       coordB <- getCoords[[input$coordB]](df=rv$space1, cov=rv$cov1, covInv=rv$covInv1, exp=rv$exp)
---
>
>
>       coordA <- getCoords(input$coordA, input$useCovA, pred, covInv, exp, user_coord)
>       coordB <- getCoords(input$coordB, input$useCovB, pred, covInv, exp, user_coord)
>
729a354
>
731a357
>
733a360
>
735a363
>
737,738c365,368
<       groupsA <- as.numeric(factor(groupsA, levels = unique(groupsA[stats::order.dendrogram(stats::as.dendrogram(fitA))])))
<       rv$colA <- palA[groupsA]
---
>       groupsA <- as.numeric(factor(groupsA,
>                                    levels=unique(groupsA[stats::order.dendrogram(stats::as.dendrogram(fitA))])))
>       colA <- palA[groupsA]
>
740,741c370,373
<       groupsB <- as.numeric(factor(groupsB, levels = unique(groupsB[stats::order.dendrogram(stats::as.dendrogram(fitB))])))
<       rv$colB <- palB[groupsB]
---
>       groupsB <- as.numeric(factor(groupsB,
>                                    levels=unique(groupsB[stats::order.dendrogram(stats::as.dendrogram(fitB))])))
>       colB <- palB[groupsB]
>
743,747c375,376
<         if (input$usegroupB) {
<          groupsB <- rv$user.group
<         palB <- unique(rv$pcol)
<         }
<         table(groupsA, groupsB) %>% as.data.frame() %>%
---
>         table(groupsA, groupsB) %>%
>           as.data.frame() %>%
749,757c378,389
<           ggplot2::geom_tile(ggplot2::aes(fill = .data$Freq)) +
<           ggplot2::geom_text(ggplot2::aes(label = .data$Freq)) +
<           ggplot2::scale_fill_distiller(palette = "RdGy") + ggplot2::theme_minimal() +
<           ggplot2::xlab("") + ggplot2::ylab("") + ggplot2::theme(legend.position = "none",
<          axis.text.x = ggplot2::element_text(colour = palA,
<              face = "bold", size = 15),
<          axis.text.y = ggplot2::element_text(colour = palB,
<              face = "bold", size = 15))
<        }, height = 325)
---
>           ggplot2::geom_tile(ggplot2::aes(fill = Freq)) +
>           ggplot2::geom_text(ggplot2::aes(label=Freq)) +
>           ochRe::scale_fill_ochre(palette="galah", discrete=FALSE) +
>           ggplot2::theme_minimal() +
>           ggplot2::xlab("") +
>           ggplot2::ylab("") +
>           ggplot2::theme(legend.position = "none",
>                 axis.text.x =
>                   ggplot2::element_text(colour = palA, face = "bold", size=15),
>                 axis.text.y =
>                   ggplot2::element_text(colour = palB, face = "bold", size=15))
>         }, height = 325)
759,765d390
<        output$heatmapA <- shiny::renderPlot({
<          plotHeatmap(d_matA, fitA, kA, palA)
<        }, height = 325)
<        output$heatmapB <- shiny::renderPlot({
<          plotHeatmap(d_matB, fitB, kB, palB)
<        }, height = 325)
<     }, ignoreInit = T)
767,779c392,394
<     output$wcA <- shiny::renderPlot({
<       shiny::req(rv$load.app)
<       plotWC(rv$space2, input$pxA, input$pyA, rv$value$is.interest, c(), rv$colA, rv$cond)
<     }, height = 325)
<     output$wcB <- shiny::renderPlot({
<       shiny::req(rv$load.app)
<       if (input$usegroupB) {
<         col <- rv$pcol
<       } else {
<         col <- rv$colB
<       }
<       plotWC(rv$space2, input$pxB, input$pyB, rv$value$is.interest, c(), col, rv$cond)
<     }, height = 325)
---
>       output$wcA <- shiny::renderPlot({
>         plotWC(wc, rv$x, rv$y, sm, bf, c(), colA, rv$cond)
>       }, height = 325)
780a396,409
>       output$wcB <- shiny::renderPlot({
>         plotWC(wc, rv$x, rv$y, sm, bf, c(), colB, rv$cond)
>       }, height = 325)
>
>       output$heatmapA <- shiny::renderPlot({
>         plotHeatmap(d_matA, fitA, kA, palA)
>       }, height = 325)
>       output$heatmapB <- shiny::renderPlot({
>         plotHeatmap(d_matB, fitB, kB, palB)
>       }, height = 325)
>
>     }
>     )
>
782c411,413
<   shiny::shinyApp(UI(), server)
---
>
>   shiny::shinyApp(ui(colnames(wc)), server)
>
Only in GabrielMccoy/pandemonium/R: tourMaker.R
diff GabrielMccoy/pandemonium/R/ui.R ushiLaa/pandemonium/R/ui.R
1d0
<
4,5c3
< #' (modified)
< #'
---
> #' @param params input parameters
8,10c6
< #'
< UI <- function () {
<
---
> ui <- function(params){
13,50c9,10
<     shinyFeedback::useShinyFeedback(),
<     shiny::tags$head(
<       shiny::tags$style(shiny::HTML("
<         #pc_vars .option[data-value='1'], #pc_vars .item[data-value='1']{
<           background: #1B9E77 !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='2'], #pc_vars .item[data-value='2']{
<           background: #D95F02 !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='3'], #pc_vars .item[data-value='3']{
<           background: #7570B3 !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='4'], #pc_vars .item[data-value='4']{
<           background: #E7298A !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='5'], #pc_vars .item[data-value='5']{
<           background: #66A61E !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='6'], #pc_vars .item[data-value='6']{
<           background: #E6AB02 !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='7'], #pc_vars .item[data-value='7']{
<           background: #A6761D !important;
<           color: white !important;
<         }
<         #pc_vars .option[data-value='8'], #pc_vars .item[data-value='8']{
<           background: #666666 !important;
<           color: white !important;
<         }
<                       "))
<     ),
<     shiny::navbarPage("pandemonium", id = "navbar",
---
>     shiny::navbarPage(
>       "pandemonium",
52,76c12,13
<       shiny::tabPanel("Data", value = "0",
<                               shiny::fluidRow(
<                                 shiny::column(6,
<                                               shiny::hr(),
<                                               shiny::selectInput('space1', 'Space 1 ', c(), multiple=TRUE, selectize=TRUE),
<                                               shiny::selectInput("coord_space1","Coordinate Funcion",c())
<                                 ),
<                                 shiny::column(6,
<                                               shiny::hr(),
<                                               shiny::selectInput('space2', 'Space 2', c(), multiple=TRUE, selectize=TRUE),
<                                               shiny::selectInput("coord_space2","Coordinate Funcion",c())
<                                 )
<                               ),
<                               shiny::fluidRow(
<                                 shiny::column(6,
<                                               shiny::hr(),
<                                               shiny::selectInput('group', 'Flags or Groupings', c(choose=""), multiple=TRUE, selectize=TRUE)
<                                 ),
<                                 shiny::column(6,
<                                               shiny::hr(),
<                                               shiny::selectInput('label', 'Label', c(choose=""), selectize=TRUE)
<                                 )
<                               ),
<                               shiny::actionButton("app.load","load data"),
<                               shiny::uiOutput("notloadedwarning")
---
>   shiny::tabPanel("Input",
>   shiny::fluidPage(
77a15,25
>   # Sidebar with a slider input for number of bins
>   shiny::sidebarLayout(
>     shiny::sidebarPanel(
>       shiny::selectInput(
>         "linkage",
>         "Linkage",
>         choices = c("complete", "single",
>                     "average", "median",
>                     "centroid", "mcquitty",
>                     "ward.D", "ward.D2"),
>         selected = "complete"
78a27,37
>       shiny::checkboxInput("useCov", "Include covariance"),
>       shiny::selectInput("coord", "Coordinates",
>                          choices = c("Pull", "p-val")),
>       shiny::selectInput("metric", "Distance measure",
>                          choices = c("euclidean", "maximum", "manhattan", "canberra",
>                                      "binary", "minkowski")),
>       shiny::selectInput("kC", "Number of clusters", choices = 2:8),
>       shiny::selectInput("px", "x", choices = params, selected = params[1]),
>       shiny::selectInput("py", "y", choices = params, selected = params[2]),
>       shiny::uiOutput("conditions1"),
>       shiny::uiOutput("conditions2")
80,81c39
<       shiny::tabPanel("Analysis", value = "1",
<           shiny::tabsetPanel(id = "tabset",
---
>     ),
83,85c41,74
<             shiny::tabPanel("Input",
<               shiny::fluidPage(
<                 shiny::h3(),
---
>     # Show a plot of the generated distribution
>     shiny::mainPanel(
>       shiny::splitLayout(cellWidths = c("50%", "50%"),
>                          cellArgs = list(style = "height: 325px"),
>                   shiny::imageOutput("heatmap"),
>                   shiny::imageOutput("chi2")),
>       shiny::splitLayout(cellWidths = c("50%", "50%"),
>                          cellArgs = list(style = "height: 325px"),
>                   shiny::imageOutput("wc"),
>                   shiny::imageOutput("sigbins"))
>     )
>   ))),
>   shiny::tabPanel("Benchmarks",
>                   shiny::fluidPage(
>                     DT::DTOutput('benchmarks')
>                   )),
>   shiny::tabPanel("Distance breakdown",
>                   shiny::fluidPage(
>                     shiny::textOutput("distText"),
>                     shiny::plotOutput("hist")
>                     )),
>   shiny::tabPanel("Coordinates",
>                   shiny::fluidPage(
>                     shiny::plotOutput("scalar"),
>                     shiny::plotOutput("pc"),
>                     shiny::plotOutput("pc2")
>                   )),
>   shiny::tabPanel("Dimension Reduction",
>                   shiny::fluidPage(
>                     shiny::splitLayout(cellWidths = c("30%", "30%", "30%"),
>                     shiny::plotOutput("tsne"),
>                     shiny::plotOutput("umap"),
>                     shiny::plotOutput("lle"))
>                     )
87,103d75
<                 # Sidebar with a drop down input for number of bins
<                 shiny::sidebarLayout(
<                   shiny::sidebarPanel(
<                     shiny::selectInput("linkage","Linkage",
<                       choices = c("complete", "single","average", "median",
<                                   "centroid", "mcquitty","ward.D", "ward.D2"),
<                       selected = "ward.D2" ),
<                     shiny::selectInput("metric", "Distance measure",
<                       choices = c("euclidean", "maximum", "manhattan",
<                                   "canberra","binary", "minkowski")),
<                     shiny::selectInput("kC", "Number of clusters", choices = 2:8, selected = 4),
<                     shiny::selectInput("px", "x", choices = c()),
<                     shiny::selectInput("py", "y", choices = c()),
<                     shiny::checkboxInput("plotHulls","Show alpha hulls"),
<                     shiny::conditionalPanel("input.plotHulls == true",shiny::sliderInput("alpha","alpha value",min = 0.1,max = 10,step = 0.1,value = 0.2))
<
<
104a77,91
>   shiny::tabPanel("Tour display",
>                   shiny::fluidPage(
>                     shiny::fluidRow(shiny::column(6,
>                     shiny::sliderInput(
>                       "n", "", min = 1, max = 100, value = 1,
>                       animate = shiny::animationOptions(interval = 100)
>                     ),
>                     shiny::imageOutput("tourImg", width = "100%")),
>                     shiny::column(6,
>                     shiny::sliderInput(
>                       "npca", "", min = 1, max = 100, value = 1,
>                       animate = shiny::animationOptions(interval = 100)
>                     ),
>                     shiny::imageOutput("tourImgPca", width = "100%")
>                   )))),
106,163c93,94
<                 # Show a plot of the generated distribution
<                   shiny::mainPanel(
<                     shiny::splitLayout(cellWidths = c("50%", "50%"),
<                       cellArgs = list(style = "height: 325px"),
<                       shiny::imageOutput("heatmap"),
<                       shiny::imageOutput("wc")),
<                     shiny::splitLayout(cellWidths = c("50%", "50%"),
<                       cellArgs = list(style = "height: 325px"),
<                       shiny::imageOutput("chi2"),
<                       shiny::imageOutput("sigbins"))
<                                                   )))),
<           shiny::tabPanel("Benchmarks",
<             shiny::fluidPage(
<               shiny::h3(),
<               shiny::conditionalPanel('input.group != ""',shiny::h3("Cluster Assignment")),
<               DT::DTOutput('benchmarks'),
<               shiny::hr(),
<               shiny::conditionalPanel('input.group != ""',shiny::h3("User Grouping")),
<               shiny::conditionalPanel('input.group != ""',DT::DTOutput('benchmarks.grouping'))
<           )),
<           shiny::tabPanel("Distance breakdown",
<             shiny::fluidPage(
<               shiny::h3(),
<               shiny::textOutput("distText"),
<               shiny::plotOutput("hist",width = "100%",height = "600px")
<           )),
<           shiny::tabPanel("Coordinates",
<             shiny::fluidPage(
<               shiny::h3(),
<               shiny::plotOutput("scalar"),
<               shiny::hr(),
<               shiny::plotOutput("pc"),
<               shiny::splitLayout(
<                 shiny::checkboxInput("pc.centre","centre",value = T),
<                 shiny::checkboxInput("pc.scale","scale",value = T),
<                 shiny::tags$div(id = "pc_vars",
<                          shiny::selectizeInput("pc.filt", "grouping selection",1:4,1:4,multiple = T))
<                 )
<           )),
<           shiny::tabPanel("Dimension reduction",
<             shiny::fluidPage(
<               shiny::h3(),
<               shiny::fluidRow(
<                 shiny::column(6,
<                               plotly::plotlyOutput("dimRed1", width = "100%", height = "500px"),
<                               shiny::selectInput("algorithm1","algorithm",c()),
<                               shiny::selectInput("red1.data","data",c("space1","space2"),selected = "space1"),
<                               shiny::selectInput("dimred.colour1","colour",
<                                                  c("clustering","sigma bins","chi squared","user"), selected = "clustering")
<                               ),
<                 shiny::column(6,
<                               plotly::plotlyOutput("dimRed2", width = "100%", height = "500px"),
<                               shiny::selectInput("algorithm2","algorithm",c()),
<                               shiny::selectInput("red2.data","data",c("space1","space2"),selected = "space2"),
<                               shiny::selectInput("dimred.colour2","colour",
<                                                  c("clustering","sigma bins","chi squared","user"), selected = "clustering")
<                               )
<               )
---
>   shiny::tabPanel("Comparison",
>                   shiny::fluidPage(
165,227c96,108
<           )),
<           shiny::tabPanel("Tour display",
<             shiny::fluidPage(
<               shiny::h3(),
<             #page with tour displays in observable and parameter space
<               shiny::fluidRow(
<                 shiny::column(6,
<                               detourr::detourOutput("tourImg1",width = "100%", height = "400px")),
<                 shiny::column(6,
<                               detourr::detourOutput("tourImg2",width = "100%", height = "400px"))
<               ),
<               shiny::fluidRow(
<                 shiny::column(6,
<                               #tour1 controls
<                               shiny::selectInput("colouring1","Colouring", choices =
<                                                    c("clustering","sigma bins","chi squared","user"), selected = "clustering"),
<                               shiny::selectInput("tour1data","data", choices =
<                                                    c("space1","space2","space1 PCA", "space2 PCA"),
<                                                  selected = "space1"),
<                               shiny::selectInput("tour_type_obs","tour type",choices =
<                                                    c("grand","cmass","holes","lda","pda","dcor","origin","spline","radial","mahalanobis","anomaly"), selected = "grand"),
<                               #radial variable selection only shown if radial selected
<                               shiny::conditionalPanel("input.tour_type_obs == 'radial'",
<                                                       shiny::selectInput("select_radial_obs","radial variable",c(), multiple = T),
<                                                       shiny::selectInput("radial_start_obs","radial start ppi",c("random","cmass","holes","lda","pda","dcor","origin","spline","mahalanobis"),selected = "random")),
<                               #ellipse scaling only shown if anomaly selected. larger value means only further points
<                               shiny::conditionalPanel("input.tour_type_obs == 'anomaly'",
<                                                       shiny::selectInput("ellc_obs","ellc",1:30,selected = 1)),
<                               #slice display selection width only shown if slice selected
<                               shiny::checkboxInput("slice_obs","Use Slice"),
<                               shiny::conditionalPanel("input.slice_obs == true",
<                                                       shiny::numericInput("slw_obs","slice width",value=0.2,min=0,max=1)),
<                               shiny::selectInput("render1","Display type",
<                                                  choices = c("2D","3D"), selected = "2D")
<                               ),
<                 shiny::column(6,
<                               #tour2 controls
<                               shiny::selectInput("colouring2","Colouring", choices =
<                                                    c("clustering","sigma bins","chi squared","user"), selected = "clustering"),
<                               shiny::selectInput("tour2data","data", choices =
<                                                    c("space1","space2","space1 PCA", "space2 PCA"),
<                                                  selected = "space2"),
<                               shiny::selectInput("tour_type_param","tour type",choices =
<                                                    c("grand","cmass","holes","lda","pda","dcor","origin","spline","radial","mahalanobis","anomaly"), selected = "grand"),
<                               #radial variable selection only shown if radial selected
<                               shiny::conditionalPanel("input.tour_type_param == 'radial'",
<                                                       shiny::selectInput("select_radial_par","radial variable", c(), multiple = T),
<                                                       shiny::selectInput("radial_start_par","radial start ppi",c("random","cmass","holes","lda","pda","dcor","origin","spline","mahalanobis"),selected = "random")),
<                               #ellipse scaling only shown if anomaly selected
<                               shiny::conditionalPanel("input.tour_type_param == 'anomaly'",
<                                                       shiny::selectInput("ellc_param","ellc",1:30,selected = 1)),
<                               #slice display selection width only shown if slice selected
<                               shiny::checkboxInput("slice_par","Use Slice"),
<                               shiny::conditionalPanel("input.slice_par == true",
<                                                       shiny::sliderInput("slw_par","slice width",min=0,max=1,value=0.2,step = .01)),
<                               shiny::selectInput("render2","Display type",
<                                                  choices = c("2D","3D"), selected = "2D")
<                               )
<               )
<           )),
<           shiny::tabPanel("Comparison",
<                           shiny::fluidPage(
<                             shiny::h3(),
---
>                     # Sidebar with a slider input for number of bins
>                     shiny::fluidRow(
>                       shiny::column(2,
>                         shiny::selectInput(
>                           "linkageA",
>                           "Linkage A",
>                           choices = c("complete", "single",
>                                       "average", "median",
>                                       "centroid", "mcquitty",
>                                       "ward.D", "ward.D2"),
>                           selected = "complete"
>                         ),
>                         shiny::checkboxInput("useCovA", "Include covariance A"),
229,270c110,134
<                             # Sidebar with a dropdown input for number of bins
<                             shiny::fluidRow(
<                               shiny::column(4,shiny::fluidRow(
<                                 shiny::column(6,
<                                               shiny::selectInput("coordA","coord",c()),
<                                               shiny::selectInput(
<                                                 "linkageA", "Linkage A",
<                                                 choices = c("complete", "single",
<                                                             "average", "median",
<                                                             "centroid", "mcquitty",
<                                                             "ward.D", "ward.D2"),
<                                                 selected = "complete"
<                                               ),
<                                               shiny::selectInput("metricA", "Distance measure A",
<                                                                  choices = c("euclidean", "maximum", "manhattan",
<                                                                              "canberra", "binary", "minkowski")),
<                                               shiny::selectInput("kA", "Number of clusters A", choices = 2:8),
<                                               shiny::selectInput("pxA", "x", choices = c()),
<                                               shiny::selectInput("pyA", "y", choices = c()),
<                                               shiny::checkboxInput("usemainA","Use Main Choices")
<                                 ),
<                                 shiny::column(6,
<                                               shiny::selectInput("coordB","coord",c()),
<                                               shiny::selectInput(
<                                                 "linkageB", "Linkage B",
<                                                 choices = c("complete", "single",
<                                                             "average", "median",
<                                                             "centroid", "mcquitty",
<                                                             "ward.D", "ward.D2"),
<                                                 selected = "complete"
<                                               ),
<                                               shiny::selectInput("metricB", "Distance measure B",
<                                                                  choices = c("euclidean", "maximum", "manhattan",
<                                                                              "canberra", "binary", "minkowski")),
<                                               shiny::selectInput("kB", "Number of clusters B", choices = 2:8),
<                                               shiny::selectInput("pxB", "x", choices = c()),
<                                               shiny::selectInput("pyB", "y", choices = c()),
<                                               shiny::conditionalPanel('input.group != ""',
<                                                                       shiny::checkboxInput("usegroupB","User Grouping")),
<                                 ),
<                                 shiny::plotOutput("tableAB")
<                               )),
---
>                         shiny::selectInput("coordA", "Coordinates A",
>                                            choices = c("Pull", "p-val")),
>                         shiny::selectInput("metricA", "Distance measure A",
>                                            choices = c("euclidean", "maximum", "manhattan",
>                                                        "canberra", "binary", "minkowski")),
>                         shiny::selectInput("kA", "Number of clusters A", choices = 2:8)
>                         ),
>                       shiny::column(2,
>                         shiny::selectInput(
>                           "linkageB",
>                           "Linkage B",
>                           choices = c("complete", "single",
>                                       "average", "median",
>                                       "centroid", "mcquitty",
>                                       "ward.D", "ward.D2"),
>                           selected = "complete"
>                         ),
>                         shiny::checkboxInput("useCovB", "Include covariance B"),
>                         shiny::selectInput("coordB", "Coordinates B",
>                                            choices = c("Pull", "p-val")),
>                         shiny::selectInput("metricB", "Distance measure B",
>                                            choices = c("euclidean", "maximum", "manhattan",
>                                                        "canberra", "binary", "minkowski")),
>                         shiny::selectInput("kB", "Number of clusters B", choices = 2:8)
>                       ),
272,293c136,154
<
<                               # Show a plot of the generated distribution
<                               shiny::column(8,
<                                             shiny::splitLayout(
<                                               cellWidths = c("50%", "50%"),
<                                               cellArgs = list(style = "height: 325px"),
<                                               shiny::plotOutput("heatmapA"),
<                                               shiny::plotOutput("heatmapB")),
<                                             shiny::splitLayout(
<                                               cellWidths = c("50%", "50%"),
<                                               cellArgs = list(style = "height: 325px"),
<                                               shiny::plotOutput("wcA"),
<                                               shiny::plotOutput("wcB"))
<                               )
<                             )
<
<           )),
<           shiny::tabPanel("Statistics",
<                           shiny::fluidPage(shiny::plotOutput("clusterstats")))
<           ))
<
<     ))}
---
>                       # Show a plot of the generated distribution
>                       shiny::column(8,
>                         shiny::splitLayout(cellWidths = c("50%", "50%"),
>                                            cellArgs = list(style = "height: 325px"),
>                         shiny::plotOutput("heatmapA"),
>                         shiny::plotOutput("heatmapB"))
>                       )
>                     ),
>                     shiny::fluidRow(
>                       shiny::column(4, shiny::plotOutput("tableAB")),
>                       shiny::column(8, shiny::splitLayout(
>                         cellWidths = c("50%", "50%"),
>                         cellArgs = list(style = "height: 325px"),
>                         shiny::plotOutput("wcA"),
>                         shiny::plotOutput("wcB")))
>                     ))),
>   shiny::tabPanel("Statistics",
>                   shiny::fluidPage(shiny::plotOutput("clusterstats")))
> ))}
